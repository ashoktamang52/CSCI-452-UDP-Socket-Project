commit d1af7f48ffb7ddbe564a682bf7639aca88d84ad1
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 23:22:52 2017 -0500

    final-1: remove logs

diff --git a/client/client.c b/client/client.c
index 380c608..5dd8a83 100644
--- a/client/client.c
+++ b/client/client.c
@@ -165,7 +165,6 @@ int main(int argc, char *argv[]) {
 
 
             /* reset buffer to get only relevant string */
-            free(buffer);
             free(buffer_received);
             free(buffer_send); 
         }
@@ -242,7 +241,6 @@ int main(int argc, char *argv[]) {
                 large_buffer = (void *) malloc(sizeof(large_buffer) * MAX_LINE);
                 read(socket_tcp, large_buffer, MAX_LINE);
 
-                printf("Server responded: %s\n", large_buffer);
                 /* write the data to the file. */
                 fp = fopen(file_name, "wb");
 

commit 574db3c7cc0da3927f8a0d1b384055809a09a304
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 23:16:22 2017 -0500

    final: file receiving buffer is made to void pointer

diff --git a/client/client.c b/client/client.c
index e5fad33..380c608 100644
--- a/client/client.c
+++ b/client/client.c
@@ -238,8 +238,8 @@ int main(int argc, char *argv[]) {
                 }
                 query_count++;
                 /*Experimental*/
-                char *large_buffer;
-                large_buffer = (char *) malloc(sizeof(large_buffer) * MAX_LINE);
+                void *large_buffer;
+                large_buffer = (void *) malloc(sizeof(large_buffer) * MAX_LINE);
                 read(socket_tcp, large_buffer, MAX_LINE);
 
                 printf("Server responded: %s\n", large_buffer);
@@ -250,11 +250,11 @@ int main(int argc, char *argv[]) {
                 int file_size = strtol(fileSize, &endptr, 0);
 
                 fwrite(large_buffer, 1, file_size, fp);
-                printf("Server responded: Data is written to the file named: %s\n", file_name);
 
                 /* close the file and free the memory */
                 fclose(fp);
                 free(large_buffer);
+                free(status_token);
 
        
             }
diff --git a/server/server.c b/server/server.c
index 67b6b11..6b27b7e 100644
--- a/server/server.c
+++ b/server/server.c
@@ -134,7 +134,6 @@ int main(int argc, char *argv[]) {
             }
             /*[> free the memory <]*/
             free(to_capitalize);
-            free(buffer);
         }
 
         if (strncmp(buffer, "FILE", 4) == 0) {
@@ -292,5 +291,6 @@ int main(int argc, char *argv[]) {
 
             free(file_name);
         }
+        free(buffer);
     }
 }

commit 8cc9d3b8ccdfd05d1c53556acf3e907b580d85dc
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 23:04:01 2017 -0500

    fix: right length of file size to be recieved

diff --git a/client/client.c b/client/client.c
index 81742c2..e5fad33 100644
--- a/client/client.c
+++ b/client/client.c
@@ -217,6 +217,18 @@ int main(int argc, char *argv[]) {
             /*If file does exist.*/
             if (strcmp(status_token, "OK") == 0) {
 
+                char *fileSize;
+                fileSize = (char *) malloc(sizeof(char*) * MAX_LINE);
+   
+               int position = 0;
+               while(status_token != NULL) {
+                   if (position == 1) 
+                       strcpy(fileSize, status_token);
+                   if (position > 1)
+                       break;
+                   position++;
+                   status_token = strtok(NULL, "\n");
+               }
                 if (query_count == 0) {
                     /*  connect() to the remote echo server  */
                     if ( connect(socket_tcp, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp) ) < 0 ) {
@@ -233,7 +245,11 @@ int main(int argc, char *argv[]) {
                 printf("Server responded: %s\n", large_buffer);
                 /* write the data to the file. */
                 fp = fopen(file_name, "wb");
-                fwrite(large_buffer, 1, strlen(large_buffer), fp);
+
+                memset(&endptr, 0, sizeof(endptr));
+                int file_size = strtol(fileSize, &endptr, 0);
+
+                fwrite(large_buffer, 1, file_size, fp);
                 printf("Server responded: Data is written to the file named: %s\n", file_name);
 
                 /* close the file and free the memory */

commit 7e30d06c9fa36acd5d994200f9441cca953b70d6
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 22:47:47 2017 -0500

    fix: use counter to enable bind/listen/connect only one time.

diff --git a/client/client.c b/client/client.c
index 401e4ee..81742c2 100644
--- a/client/client.c
+++ b/client/client.c
@@ -68,6 +68,34 @@ int main(int argc, char *argv[]) {
 
     /* TCP connection */
 
+    /*Set up TCP connection*/
+
+    tcp_port = strtol(tcpPort, &endptr, 0);
+    if ( *endptr ) {
+        fprintf(stderr, "ECHOSERV: Invalid port number.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    /*  Create the listening socket  */
+
+    if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+        fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    /*Set all bytes in socket address structure to*/
+    /*zero, and fill in the relevant data members   */
+
+    memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
+    servaddr_tcp.sin_family      = AF_INET;
+    servaddr_tcp.sin_port        = htons(tcp_port);
+
+    /*Set remote ip address*/
+    if (inet_aton(szAddress, &servaddr_tcp.sin_addr) <= 0) {
+        perror("Invalid IP address:");
+        exit(EXIT_FAILURE);
+    }
+
     /*  Set the remote port  */
 
 
@@ -99,6 +127,7 @@ int main(int argc, char *argv[]) {
     servaddr_udp.sin_addr.s_addr = htonl(INADDR_ANY);
 
     /*  Get string to follow user commands */
+    int query_count = 0;
     do {
         buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
         printf("Insert your command: ");
@@ -114,12 +143,10 @@ int main(int argc, char *argv[]) {
 
             /*CAP + 2 new lines + null terminator = 6*/
             buffer_send =  (char *) malloc(sizeof(buffer_send) * (strlen(buffer))); 
-            printf("size of buffer: %d\n", strlen(buffer));
             /* Format the input string */
             strcpy(buffer_send, "CAP\n");
             strcat(buffer_send, buffer);
 
-            printf("to send length: %d\n", strlen(buffer_send));
             /*Send message to server via UDP*/
             if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr_udp, sizeof(servaddr_udp)) < 0) {
                 perror("Send to, failed.");
@@ -132,16 +159,15 @@ int main(int argc, char *argv[]) {
             recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
             if (recvlen > 0) {
                 buffer_received[recvlen] = '\0';
-                printf("total bytest received: %d.\n", recvlen);
-                printf("Server responded: %s\n", buffer_received);
             }
 
+            printf("Server responded: %s\n", buffer_received);
+
 
             /* reset buffer to get only relevant string */
             free(buffer);
             free(buffer_received);
             free(buffer_send); 
-            /*printf("Server responded: %s", buffer);*/
         }
         else if (strncmp(buffer, "t", 1) == 0) {
             /*Reset buffer to get the string.*/
@@ -159,14 +185,10 @@ int main(int argc, char *argv[]) {
             /*Format the input string */
             strcpy(buffer_send, "FILE\n");
             strcat(buffer_send, buffer);
-            printf("before port is attached: %s", buffer_send);
-            
+
             strcat(buffer_send, tcpPort);
             strcat(buffer_send, "\n");
 
-            /*Debug*/
-            printf("to be send: %s\n", buffer_send);
-            printf("to be send len: %d\n", strlen(buffer_send));
 
             /* Send message to server. */
             if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr_udp, sizeof(servaddr_udp)) < 0) {
@@ -180,8 +202,6 @@ int main(int argc, char *argv[]) {
             recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
             if (recvlen > 0) {
                 buffer_received[recvlen] = '\0';
-                printf("total bytest received: %d.\n", recvlen);
-                printf("Server responded: %s\n", buffer_received);
             }
 
 
@@ -189,7 +209,6 @@ int main(int argc, char *argv[]) {
             char *status_token = (char *) malloc(sizeof(status_token) * MAX_LINE);
             strcpy(status_token, buffer_received);
             status_token = strtok(status_token, "\n");
-            printf("status?: %s\n", status_token);
 
             /*Holds file name without new line character.*/
             temp = (char *) malloc(sizeof(temp) * MAX_LINE);
@@ -197,72 +216,36 @@ int main(int argc, char *argv[]) {
 
             /*If file does exist.*/
             if (strcmp(status_token, "OK") == 0) {
-                printf("Transfer started....\n");
-                
-                /*Set up TCP connection*/
-
-                tcp_port = strtol(tcpPort, &endptr, 0);
-                if ( *endptr ) {
-                    fprintf(stderr, "ECHOSERV: Invalid port number.\n");
-                    exit(EXIT_FAILURE);
-                }
-
-                printf("tcp_port: %d\n", tcp_port);
-
-                /*  Create the listening socket  */
 
-                if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
-                    fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
-                    exit(EXIT_FAILURE);
+                if (query_count == 0) {
+                    /*  connect() to the remote echo server  */
+                    if ( connect(socket_tcp, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp) ) < 0 ) {
+                        perror("Connection failed");
+                        exit(EXIT_FAILURE);
+                    }
                 }
-
-                /*Set all bytes in socket address structure to*/
-                /*zero, and fill in the relevant data members   */
-
-                memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
-                servaddr_tcp.sin_family      = AF_INET;
-                servaddr_tcp.sin_port        = htons(tcp_port);
-                
-                /*Set remote ip address*/
-                if (inet_aton(szAddress, &servaddr_tcp.sin_addr) <= 0) {
-                    perror("Invalid IP address:");
-                    exit(EXIT_FAILURE);
-                }
-
-                /*  connect() to the remote echo server  */
-                if ( connect(socket_tcp, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp) ) < 0 ) {
-                    perror("Connection failed");
-                    exit(EXIT_FAILURE);
-                }
-                
+                query_count++;
                 /*Experimental*/
-                free(buffer);
-                buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
-                read(socket_tcp, buffer, MAX_LINE);
+                char *large_buffer;
+                large_buffer = (char *) malloc(sizeof(large_buffer) * MAX_LINE);
+                read(socket_tcp, large_buffer, MAX_LINE);
 
-                printf("Server responded: %s\n", buffer);
+                printf("Server responded: %s\n", large_buffer);
                 /* write the data to the file. */
                 fp = fopen(file_name, "wb");
-                fwrite(buffer, 1, strlen(buffer), fp);
+                fwrite(large_buffer, 1, strlen(large_buffer), fp);
                 printf("Server responded: Data is written to the file named: %s\n", file_name);
 
                 /* close the file and free the memory */
                 fclose(fp);
-                
-                if (shutdown(socket_tcp, 2) < 0) {
-                    perror("Error calling shutdown()\n");
-                    exit(EXIT_FAILURE);
-                }
-                int opt = 1;
-                setsockopt(socket_tcp, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
+                free(large_buffer);
+
+       
             }
             else {
                 printf("%s not found.\n", temp);
             }
 
-
-
-
             /*Free memory*/
             free(buffer);
             free(buffer_received);
@@ -270,35 +253,35 @@ int main(int argc, char *argv[]) {
             free(file_name);
             free(temp);
         }
-            else if (strncmp(buffer, "q", 1) == 0) {
-                fprintf(stderr, "Now should exit.\n");
-                if (close(socket_tcp) < 0 ) {
-                    fprintf(stderr, "ECHOSERV: Error calling close()\n");
-                    exit(EXIT_FAILURE);
-                }
-
-                return EXIT_SUCCESS;
+        else if (strncmp(buffer, "q", 1) == 0) {
+            fprintf(stderr, "Now should exit.\n");
+            if (close(socket_tcp) < 0 ) {
+                fprintf(stderr, "ECHOSERV: Error calling close()\n");
+                exit(EXIT_FAILURE);
             }
-            else 
-                printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
-        } while (strncmp(buffer, "q", 1) != 0);
 
-        return EXIT_SUCCESS;
-    }
+            return EXIT_SUCCESS;
+        }
+        else 
+            printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
+    } while (strncmp(buffer, "q", 1) != 0);
 
+    return EXIT_SUCCESS;
+}
 
-    int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort) {
-        /* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
-        if (argc == 4) {
-            *tcpPort = argv[1];
-            *szAddress = argv[2];
-            *udpPort = argv[3];
-        }
-        else {
-            printf("Usage:\n\n");
-            printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
-            exit(EXIT_SUCCESS);
-        }
-        return 0;
+
+int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort) {
+    /* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
+    if (argc == 4) {
+        *tcpPort = argv[1];
+        *szAddress = argv[2];
+        *udpPort = argv[3];
+    }
+    else {
+        printf("Usage:\n\n");
+        printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
+        exit(EXIT_SUCCESS);
     }
+    return 0;
+}
 
diff --git a/server/server.c b/server/server.c
index 9e654b6..67b6b11 100644
--- a/server/server.c
+++ b/server/server.c
@@ -93,6 +93,7 @@ int main(int argc, char *argv[]) {
 
 
     /*  Enter an infinite loop to respond to client requests.  */
+    int query_count = 0;
 
     while ( 1 ) {
         /*UDP connection*/
@@ -100,19 +101,15 @@ int main(int argc, char *argv[]) {
         int recvlen = 0;
         buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
         recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
-        printf("recieved %d bytes\n", recvlen);
         if (recvlen > 0) {
             buffer[recvlen] = '\0';
-            printf("received message: \"%s\"\n", buffer);
         }
-        printf("buffer len: %d\n.", strlen(buffer));
 
         if (strncmp(buffer, "CAP", 3) == 0) {
             /*number of relevant bytes of message */
             /*= buffer length - 'CAP' length - length of two line breaks - end of string */
             to_capitalize = (char *) malloc(sizeof(to_capitalize) * strlen(buffer));
             strncpy(to_capitalize, buffer + 4, recvlen - 4);
-            printf("what to upper?: %s", to_capitalize);
             /*[> Capitalize the messsage <]*/
             int index = 0;
             while (to_capitalize[index] != '\0') {
@@ -127,8 +124,6 @@ int main(int argc, char *argv[]) {
 
 
             /*[> parse the capitalized message to send to the client <]*/
-            printf("to send: %s\n", to_capitalize);
-            printf("to send length: %d\n", strlen(to_capitalize));
             /*[> send the formatted message to the client <]*/
             int sentlen = 0;
 
@@ -175,14 +170,11 @@ int main(int argc, char *argv[]) {
 
 
             /*Check if the file exists.*/
-            printf("Search file: %s.\n", file_name);
-            printf("TCP port in string: %s\n", string_port);
 
             /* Find file name and read that file */
             fp = fopen(file_name, "rb");
             if (fp) {
 
-                printf("Do you even go here?\n");
                 /*Read the file and file size.*/
                 long lSize;
                 void* large_buffer;
@@ -200,13 +192,10 @@ int main(int argc, char *argv[]) {
                 temp = (char *) malloc(sizeof(temp) * MAX_LINE);
                 buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
 
-                sprintf(temp, "%Ld", lSize);
-                printf("size of file: %Ld\n", lSize);
                 strcpy(buffer_send, "OK\n");
                 strcat(buffer_send, temp);
                 strcat(buffer_send, "\n");
 
-                printf("stats ok mesg: %s\n", buffer_send); /*debug*/
 
                 /*Send Status message to client.*/
                 if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen) < 0) {
@@ -230,78 +219,55 @@ int main(int argc, char *argv[]) {
                 /* close the file and later free the large_buffer */
                 fclose(fp);
 
-                /*Set up TCP connection*/
-                /*Create the listening socket  */
-
-                /*Free endptr before using*/
-                /*free(endptr);*/
-
-                memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for tcp_port */
-                tcp_port = strtol(string_port, &endptr, 0);
-                /*free(string_port);*/
-                if ( *endptr ) {
-                    printf("ECHOCLNT: Invalid port supplied.\n");
-                    exit(EXIT_FAILURE);
-                }
-                if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
-                    perror("ECHOSERV: Error creating listening socket.\n");
-
-                    exit(EXIT_FAILURE);
-                }
-
+                if (query_count == 0) {
+                    /*Set up TCP connection*/
+                    /*Create the listening socket  */
+
+                    /*Free endptr before using*/
+                    /*free(endptr);*/
+                    memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for tcp_port */
+                    tcp_port = strtol(string_port, &endptr, 0);
+                    /*free(string_port);*/
+                    if ( *endptr ) {
+                        printf("ECHOCLNT: Invalid port supplied.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                    if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+                        perror("ECHOSERV: Error creating listening socket.\n");
 
-                /*Set all bytes in socket address structure to*/
-                /*zero, and fill in the relevant data members   */
+                        exit(EXIT_FAILURE);
+                    }
 
-                memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
-                servaddr_tcp.sin_family      = AF_INET;
-                servaddr_tcp.sin_port        = htons(tcp_port);
-                servaddr_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
 
-                /*Bind our socket addresss to the */
-                /*listening socket, and call listen()  */
+                    /*Set all bytes in socket address structure to*/
+                    /*zero, and fill in the relevant data members   */
 
-                if ( bind(list_s, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp)) < 0 ) {
-                    perror("Error calling bind()\n");
-                    exit(EXIT_FAILURE);
-                }
+                    memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
+                    servaddr_tcp.sin_family      = AF_INET;
+                    servaddr_tcp.sin_port        = htons(tcp_port);
+                    servaddr_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
 
-                if ( listen(list_s, LISTENQ) < 0 ) {
-                    perror("ECHOSERV: Error calling listen()\n");
-                    exit(EXIT_FAILURE);
-                }
+                    /*Bind our socket addresss to the */
+                    /*listening socket, and call listen()  */
 
-                while (1) {
-                    /*Wait for a connection, then accept() it  */
+                    if ( bind(list_s, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp)) < 0 ) {
+                        perror("Error calling bind()\n");
+                        exit(EXIT_FAILURE);
+                    }
 
+                    if ( listen(list_s, LISTENQ) < 0 ) {
+                        perror("ECHOSERV: Error calling listen()\n");
+                        exit(EXIT_FAILURE);
+                    }
                     if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {
                         perror("Error in calling accept():");
                         exit(EXIT_FAILURE);
                     }
 
-                    write(socket_tcp, large_buffer, lSize); 
-                    break;
-                }
-
-                /*Close socket_tcp.*/
-                if (shutdown(socket_tcp, 2) < 0) {
-                    perror("Error calling shutdown()\n");
-                    exit(EXIT_FAILURE);
-                }
-
-                /*Close list_s.*/
-                if (shutdown(list_s, 2) < 0) {
-                    perror("Error calling shutdown()\n");
-                    exit(EXIT_FAILURE);
-                }
-                else {
-                    printf("Transfer complete.\n");
                 }
+                query_count++;
 
-                int opt = 1;
-                setsockopt(socket_tcp, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
-                setsockopt(list_s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
-
+                write(socket_tcp, large_buffer, lSize); 
                 
                 /* free memory from local pointers */
                 free(temp);
@@ -313,8 +279,6 @@ int main(int argc, char *argv[]) {
                 buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
                 strcpy(buffer_send, "NOT FOUND\n");
 
-                printf("to send: %s\n", buffer_send);
-                printf("to send len: %d\n", strlen(buffer_send));
 
                 /*Send message to client.*/
 
@@ -327,47 +291,6 @@ int main(int argc, char *argv[]) {
             }
 
             free(file_name);
-            /*free(tcp_port);*/
         }
     }
 }
-
-/*[> send the buffer to the client <]*/
-/*if (MAX_LINE < lSize) {*/
-/*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
-/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-/*}*/
-/*else {*/
-/*sprintf(buffer_send, "%d", lSize);*/
-/*strcat(buffer_send, "\n");*/
-/*strcat(buffer_send, large_buffer);*/
-/*write(socket_tcp, buffer_send, lSize);*/
-/*}*/
-
-/*[> free the memory <]*/
-/*free(large_buffer);*/
-/*free(file_name);*/
-/*} else {*/
-/*[> No such file <]*/
-/*strcpy(buffer, "NOT FOUND");*/
-/*sprintf(buffer_send, "%d", strlen(buffer));*/
-/*strcat(buffer_send, "\n");*/
-/*strcat(buffer_send, buffer);*/
-
-/*[> Inform client that file is not in the server. <]*/
-/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-/*}*/
-
-/*}*/
-
-/*   [>* free the memory */
-
-/*  Close the connected socket  */
-/*         if ( close(socket_tcp) < 0 ) {*/
-/*perror("ECHOSERV: Error calling close()\n");*/
-/*exit(EXIT_FAILURE);*/
-/*}*/
-/*else {*/
-/*fprintf(stderr, "Connection closed.\n");*/
-/*}*/
-

commit c5e664279218368e6792cc9a93cc582d15aa902c
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 21:35:46 2017 -0500

    fix: unbinding issue still persists.

diff --git a/client/client.c b/client/client.c
index 390f4a4..401e4ee 100644
--- a/client/client.c
+++ b/client/client.c
@@ -249,8 +249,8 @@ int main(int argc, char *argv[]) {
                 /* close the file and free the memory */
                 fclose(fp);
                 
-                if (close(socket_tcp) < 0) {
-                    perror("Error calling close()\n");
+                if (shutdown(socket_tcp, 2) < 0) {
+                    perror("Error calling shutdown()\n");
                     exit(EXIT_FAILURE);
                 }
                 int opt = 1;
diff --git a/server/server.c b/server/server.c
index f37857c..9e654b6 100644
--- a/server/server.c
+++ b/server/server.c
@@ -284,14 +284,14 @@ int main(int argc, char *argv[]) {
                 }
 
                 /*Close socket_tcp.*/
-                if (close(socket_tcp) < 0) {
-                    perror("Error calling close()\n");
+                if (shutdown(socket_tcp, 2) < 0) {
+                    perror("Error calling shutdown()\n");
                     exit(EXIT_FAILURE);
                 }
 
                 /*Close list_s.*/
-                if (close(list_s) < 0) {
-                    perror("Error calling close()\n");
+                if (shutdown(list_s, 2) < 0) {
+                    perror("Error calling shutdown()\n");
                     exit(EXIT_FAILURE);
                 }
                 else {

commit b958aaba5a3a70e26f7abfbfdcdd69e1e4dc4194
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 21:17:40 2017 -0500

    error: bind error: Address already in use.

diff --git a/client/client.c b/client/client.c
index 9d84bb1..390f4a4 100644
--- a/client/client.c
+++ b/client/client.c
@@ -245,8 +245,16 @@ int main(int argc, char *argv[]) {
                 fp = fopen(file_name, "wb");
                 fwrite(buffer, 1, strlen(buffer), fp);
                 printf("Server responded: Data is written to the file named: %s\n", file_name);
+
                 /* close the file and free the memory */
                 fclose(fp);
+                
+                if (close(socket_tcp) < 0) {
+                    perror("Error calling close()\n");
+                    exit(EXIT_FAILURE);
+                }
+                int opt = 1;
+                setsockopt(socket_tcp, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
             }
             else {
                 printf("%s not found.\n", temp);
diff --git a/server/server.c b/server/server.c
index c831b10..f37857c 100644
--- a/server/server.c
+++ b/server/server.c
@@ -151,7 +151,7 @@ int main(int argc, char *argv[]) {
             /*Temp pointer to hold string tcp port.*/
             char *string_port;
             string_port = (char *) malloc(sizeof(string_port) * 10);
-            
+
             char *token; /*for parsing the message into file name and port */
             const char delim = '\n';
             token = (char *) malloc(sizeof(token) * strlen(buffer)+1);
@@ -181,7 +181,7 @@ int main(int argc, char *argv[]) {
             /* Find file name and read that file */
             fp = fopen(file_name, "rb");
             if (fp) {
-               
+
                 printf("Do you even go here?\n");
                 /*Read the file and file size.*/
                 long lSize;
@@ -192,14 +192,14 @@ int main(int argc, char *argv[]) {
                 fseek(fp, 0, SEEK_END);
                 lSize = ftell(fp);
                 rewind(fp); /* Put the postion of pointer back to the start of the file */
-                
+
                 /*Inform client that file exists.*/
-                
+
                 /*Format status message.*/
-               
+
                 temp = (char *) malloc(sizeof(temp) * MAX_LINE);
                 buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
-               
+
                 sprintf(temp, "%Ld", lSize);
                 printf("size of file: %Ld\n", lSize);
                 strcpy(buffer_send, "OK\n");
@@ -283,17 +283,25 @@ int main(int argc, char *argv[]) {
                     break;
                 }
 
-                /*Force unbind socket.*/
-                int true = 1;
-                setsockopt(socket_tcp, SOL_SOCKET, SO_REUSEADDR, &true, sizeof(int));
+                /*Close socket_tcp.*/
                 if (close(socket_tcp) < 0) {
                     perror("Error calling close()\n");
                     exit(EXIT_FAILURE);
                 }
+
+                /*Close list_s.*/
+                if (close(list_s) < 0) {
+                    perror("Error calling close()\n");
+                    exit(EXIT_FAILURE);
+                }
                 else {
                     printf("Transfer complete.\n");
                 }
 
+                int opt = 1;
+                setsockopt(socket_tcp, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
+                setsockopt(list_s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
+
                 
                 /* free memory from local pointers */
                 free(temp);
@@ -302,18 +310,18 @@ int main(int argc, char *argv[]) {
             }
             else {
                 /*Inform client that file doesn't exist*/
-               buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
-               strcpy(buffer_send, "NOT FOUND\n");
+                buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
+                strcpy(buffer_send, "NOT FOUND\n");
+
+                printf("to send: %s\n", buffer_send);
+                printf("to send len: %d\n", strlen(buffer_send));
 
-               printf("to send: %s\n", buffer_send);
-               printf("to send len: %d\n", strlen(buffer_send));
+                /*Send message to client.*/
 
-               /*Send message to client.*/
-               
-               if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen) < 0) {
-                   perror("Failed to send no file status.");
-                   exit(EXIT_FAILURE);
-               }
+                if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen) < 0) {
+                    perror("Failed to send no file status.");
+                    exit(EXIT_FAILURE);
+                }
 
 
             }
@@ -324,42 +332,42 @@ int main(int argc, char *argv[]) {
     }
 }
 
-            /*[> send the buffer to the client <]*/
-            /*if (MAX_LINE < lSize) {*/
-            /*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
-            /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-            /*}*/
-            /*else {*/
-            /*sprintf(buffer_send, "%d", lSize);*/
-            /*strcat(buffer_send, "\n");*/
-            /*strcat(buffer_send, large_buffer);*/
-            /*write(socket_tcp, buffer_send, lSize);*/
-            /*}*/
-
-            /*[> free the memory <]*/
-            /*free(large_buffer);*/
-            /*free(file_name);*/
-            /*} else {*/
-            /*[> No such file <]*/
-            /*strcpy(buffer, "NOT FOUND");*/
-            /*sprintf(buffer_send, "%d", strlen(buffer));*/
-            /*strcat(buffer_send, "\n");*/
-            /*strcat(buffer_send, buffer);*/
-
-            /*[> Inform client that file is not in the server. <]*/
-            /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-            /*}*/
-
-            /*}*/
-
-            /*   [>* free the memory */
-
-            /*  Close the connected socket  */
-            /*         if ( close(socket_tcp) < 0 ) {*/
-            /*perror("ECHOSERV: Error calling close()\n");*/
-            /*exit(EXIT_FAILURE);*/
-            /*}*/
-            /*else {*/
-            /*fprintf(stderr, "Connection closed.\n");*/
-            /*}*/
+/*[> send the buffer to the client <]*/
+/*if (MAX_LINE < lSize) {*/
+/*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
+/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+/*}*/
+/*else {*/
+/*sprintf(buffer_send, "%d", lSize);*/
+/*strcat(buffer_send, "\n");*/
+/*strcat(buffer_send, large_buffer);*/
+/*write(socket_tcp, buffer_send, lSize);*/
+/*}*/
+
+/*[> free the memory <]*/
+/*free(large_buffer);*/
+/*free(file_name);*/
+/*} else {*/
+/*[> No such file <]*/
+/*strcpy(buffer, "NOT FOUND");*/
+/*sprintf(buffer_send, "%d", strlen(buffer));*/
+/*strcat(buffer_send, "\n");*/
+/*strcat(buffer_send, buffer);*/
+
+/*[> Inform client that file is not in the server. <]*/
+/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+/*}*/
+
+/*}*/
+
+/*   [>* free the memory */
+
+/*  Close the connected socket  */
+/*         if ( close(socket_tcp) < 0 ) {*/
+/*perror("ECHOSERV: Error calling close()\n");*/
+/*exit(EXIT_FAILURE);*/
+/*}*/
+/*else {*/
+/*fprintf(stderr, "Connection closed.\n");*/
+/*}*/
 

commit 8ef7f8e5badf58ffdbed4712e625244dec5596bf
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 20:52:06 2017 -0500

    Use 'setsockopt()' to force unbind socket.

diff --git a/server/server.c b/server/server.c
index 3fdc62f..c831b10 100644
--- a/server/server.c
+++ b/server/server.c
@@ -262,7 +262,7 @@ int main(int argc, char *argv[]) {
                 /*listening socket, and call listen()  */
 
                 if ( bind(list_s, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp)) < 0 ) {
-                    fprintf(stderr, "ECHOSERV: Error calling bind()\n");
+                    perror("Error calling bind()\n");
                     exit(EXIT_FAILURE);
                 }
 
@@ -282,6 +282,10 @@ int main(int argc, char *argv[]) {
                     write(socket_tcp, large_buffer, lSize); 
                     break;
                 }
+
+                /*Force unbind socket.*/
+                int true = 1;
+                setsockopt(socket_tcp, SOL_SOCKET, SO_REUSEADDR, &true, sizeof(int));
                 if (close(socket_tcp) < 0) {
                     perror("Error calling close()\n");
                     exit(EXIT_FAILURE);

commit bd8dd4d991d7204f5e1742480a96734b84ef62ad
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 20:38:14 2017 -0500

    Implement read/write logic for binary file.

diff --git a/client/client.c b/client/client.c
index ba1aff8..9d84bb1 100644
--- a/client/client.c
+++ b/client/client.c
@@ -241,6 +241,12 @@ int main(int argc, char *argv[]) {
                 read(socket_tcp, buffer, MAX_LINE);
 
                 printf("Server responded: %s\n", buffer);
+                /* write the data to the file. */
+                fp = fopen(file_name, "wb");
+                fwrite(buffer, 1, strlen(buffer), fp);
+                printf("Server responded: Data is written to the file named: %s\n", file_name);
+                /* close the file and free the memory */
+                fclose(fp);
             }
             else {
                 printf("%s not found.\n", temp);
@@ -248,16 +254,6 @@ int main(int argc, char *argv[]) {
 
 
 
-            /*[> write the data to the file. <]*/
-            /*if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {*/
-            /*printf("Server responded: %s\n", buffer_received + 2);*/
-            /*}*/
-            /*else {*/
-            /*fp = fopen(file_name, "wb");*/
-            /*fwrite(buffer_received, 1, strlen(buffer_received), fp);*/
-            /*printf("Server responded: Data is written to the file named: %s\n", file_name);*/
-            /*[> close the file and free the memory <]*/
-            /*fclose(fp);*/
 
             /*Free memory*/
             free(buffer);
diff --git a/server/server.c b/server/server.c
index 14680fd..3fdc62f 100644
--- a/server/server.c
+++ b/server/server.c
@@ -279,9 +279,7 @@ int main(int argc, char *argv[]) {
                         exit(EXIT_FAILURE);
                     }
 
-                    char temp2[10];
-                    sprintf(temp2, "hello");
-                    write(socket_tcp, temp2, strlen(temp2)); 
+                    write(socket_tcp, large_buffer, lSize); 
                     break;
                 }
                 if (close(socket_tcp) < 0) {

commit df7ecae2c1a38b8af68d821114a62f8a6a3c6531
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 20:13:54 2017 -0500

    Implement 'smooth' closing of tcp connection.

diff --git a/client/client.c b/client/client.c
index 8a328b1..ba1aff8 100644
--- a/client/client.c
+++ b/client/client.c
@@ -222,6 +222,7 @@ int main(int argc, char *argv[]) {
                 memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
                 servaddr_tcp.sin_family      = AF_INET;
                 servaddr_tcp.sin_port        = htons(tcp_port);
+                
                 /*Set remote ip address*/
                 if (inet_aton(szAddress, &servaddr_tcp.sin_addr) <= 0) {
                     perror("Invalid IP address:");
@@ -234,9 +235,12 @@ int main(int argc, char *argv[]) {
                     exit(EXIT_FAILURE);
                 }
                 
-                char temp2[10];
-                sprintf(temp2, "hello");
-                write(socket_tcp, temp2, strlen(temp2)); 
+                /*Experimental*/
+                free(buffer);
+                buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
+                read(socket_tcp, buffer, MAX_LINE);
+
+                printf("Server responded: %s\n", buffer);
             }
             else {
                 printf("%s not found.\n", temp);
diff --git a/server/server.c b/server/server.c
index 77ae843..14680fd 100644
--- a/server/server.c
+++ b/server/server.c
@@ -279,13 +279,17 @@ int main(int argc, char *argv[]) {
                         exit(EXIT_FAILURE);
                     }
 
-                    /*Experimental*/
-                    /*free(buffer);*/
-                    /*buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);*/
-                    /*read(socket_tcp, buffer, MAX_LINE);*/
-
-                    /*printf("Server responded: %s\n", buffer);*/
-
+                    char temp2[10];
+                    sprintf(temp2, "hello");
+                    write(socket_tcp, temp2, strlen(temp2)); 
+                    break;
+                }
+                if (close(socket_tcp) < 0) {
+                    perror("Error calling close()\n");
+                    exit(EXIT_FAILURE);
+                }
+                else {
+                    printf("Transfer complete.\n");
                 }
 
                 
@@ -314,7 +318,6 @@ int main(int argc, char *argv[]) {
 
             free(file_name);
             /*free(tcp_port);*/
-            free(endptr);
         }
     }
 }

commit 58d6ff37c5b776ea00aeafceff8544a4d43ef7f3
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 19:54:42 2017 -0500

    fix: tcp connection (logic swap issue)

diff --git a/client/client.c b/client/client.c
index a607ff6..8a328b1 100644
--- a/client/client.c
+++ b/client/client.c
@@ -72,34 +72,6 @@ int main(int argc, char *argv[]) {
 
 
 
-    /*[>  Create the listening socket  <]*/
-
-    /*if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
-    /*fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");*/
-    /*exit(EXIT_FAILURE);*/
-    /*}*/
-
-    /*  Set all bytes in socket address structure to*/
-    /*zero, and fill in the relevant data members   */
-
-    /*memset(&servaddr_udp, 0, sizeof(servaddr_udp));*/
-    /*servaddr_udp.sin_family      = AF_INET;*/
-    /*servaddr_udp.sin_port        = htons(tcp_port);*/
-
-    /*[>  Set the remote IP address  <]*/
-
-    /*if ( inet_aton(szAddress, &servaddr_udp.sin_addr) <= 0 ) {*/
-    /*printf("ECHOCLNT: Invalid remote IP address.\n");*/
-    /*exit(EXIT_FAILURE);*/
-    /*}*/
-
-
-    /*[>  connect() to the remote echo server  <]*/
-
-    /*if ( connect(socket_tcp, (struct sockaddr *) &servaddr_udp, sizeof(servaddr_udp) ) < 0 ) {*/
-    /*perror("Connection failed");*/
-    /*exit(EXIT_FAILURE);*/
-    /*}*/
 
     /* UDP connection */
 
@@ -228,62 +200,43 @@ int main(int argc, char *argv[]) {
                 printf("Transfer started....\n");
                 
                 /*Set up TCP connection*/
-                /*Create the listening socket  */
-
-                /*Free endptr before using*/
-                /*free(endptr);*/
 
                 tcp_port = strtol(tcpPort, &endptr, 0);
                 if ( *endptr ) {
-                    printf("ECHOCLNT: Invalid port supplied.\n");
+                    fprintf(stderr, "ECHOSERV: Invalid port number.\n");
                     exit(EXIT_FAILURE);
                 }
-                if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
-                    perror("ECHOSERV: Error creating listening socket.\n");
 
+                printf("tcp_port: %d\n", tcp_port);
+
+                /*  Create the listening socket  */
+
+                if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+                    fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
                     exit(EXIT_FAILURE);
                 }
 
-
                 /*Set all bytes in socket address structure to*/
                 /*zero, and fill in the relevant data members   */
 
                 memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
                 servaddr_tcp.sin_family      = AF_INET;
-                servaddr_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
                 servaddr_tcp.sin_port        = htons(tcp_port);
-
-
-                /*Bind our socket addresss to the */
-                /*listening socket, and call listen()  */
-
-                if ( bind(list_s, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp)) < 0 ) {
-                    fprintf(stderr, "ECHOSERV: Error calling bind()\n");
+                /*Set remote ip address*/
+                if (inet_aton(szAddress, &servaddr_tcp.sin_addr) <= 0) {
+                    perror("Invalid IP address:");
                     exit(EXIT_FAILURE);
                 }
 
-                if ( listen(list_s, LISTENQ) < 0 ) {
-                    perror("ECHOSERV: Error calling listen()\n");
+                /*  connect() to the remote echo server  */
+                if ( connect(socket_tcp, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp) ) < 0 ) {
+                    perror("Connection failed");
                     exit(EXIT_FAILURE);
                 }
-
-                while (1) {
-                    /*Wait for a connection, then accept() it  */
-
-                    if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {
-                        perror("Error in calling accept():");
-                        exit(EXIT_FAILURE);
-                    }
-
-                    /*Experimental*/
-                    /*free(buffer);*/
-                    /*buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);*/
-                    /*read(socket_tcp, buffer, MAX_LINE);*/
-
-                    /*printf("Server responded: %s\n", buffer);*/
-
-                }
-
+                
+                char temp2[10];
+                sprintf(temp2, "hello");
+                write(socket_tcp, temp2, strlen(temp2)); 
             }
             else {
                 printf("%s not found.\n", temp);
diff --git a/server/server.c b/server/server.c
index 22ecea3..77ae843 100644
--- a/server/server.c
+++ b/server/server.c
@@ -56,6 +56,7 @@ int main(int argc, char *argv[]) {
     /*  Get port number from the command line.*/
 
     if ( argc == 2 ) {
+        memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for udp_port */
         udp_port = strtol(argv[1], &endptr, 0);
         if ( *endptr ) {
             fprintf(stderr, "ECHOSERV: Invalid port number.\n");
@@ -230,41 +231,64 @@ int main(int argc, char *argv[]) {
                 fclose(fp);
 
                 /*Set up TCP connection*/
-                /*free(endptr); [>free memory before using. <]*/
+                /*Create the listening socket  */
+
+                /*Free endptr before using*/
+                /*free(endptr);*/
+
+                memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for tcp_port */
                 tcp_port = strtol(string_port, &endptr, 0);
                 /*free(string_port);*/
-
                 if ( *endptr ) {
-                    fprintf(stderr, "ECHOSERV: Invalid port number.\n");
+                    printf("ECHOCLNT: Invalid port supplied.\n");
                     exit(EXIT_FAILURE);
                 }
+                if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+                    perror("ECHOSERV: Error creating listening socket.\n");
 
-                printf("tcp_port: %d\n", tcp_port);
-
-                /*  Create the listening socket  */
-
-                if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
-                    fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
                     exit(EXIT_FAILURE);
                 }
 
+
                 /*Set all bytes in socket address structure to*/
                 /*zero, and fill in the relevant data members   */
 
                 memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
                 servaddr_tcp.sin_family      = AF_INET;
                 servaddr_tcp.sin_port        = htons(tcp_port);
-                servaddr_tcp.sin_addr.s_addr = htnol(INADDR_ANY);
+                servaddr_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
+
+                /*Bind our socket addresss to the */
+                /*listening socket, and call listen()  */
 
-                /*  connect() to the remote echo server  */
-                if ( connect(socket_tcp, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp) ) < 0 ) {
-                    perror("Connection failed");
+                if ( bind(list_s, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp)) < 0 ) {
+                    fprintf(stderr, "ECHOSERV: Error calling bind()\n");
                     exit(EXIT_FAILURE);
                 }
+
+                if ( listen(list_s, LISTENQ) < 0 ) {
+                    perror("ECHOSERV: Error calling listen()\n");
+                    exit(EXIT_FAILURE);
+                }
+
+                while (1) {
+                    /*Wait for a connection, then accept() it  */
+
+                    if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {
+                        perror("Error in calling accept():");
+                        exit(EXIT_FAILURE);
+                    }
+
+                    /*Experimental*/
+                    /*free(buffer);*/
+                    /*buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);*/
+                    /*read(socket_tcp, buffer, MAX_LINE);*/
+
+                    /*printf("Server responded: %s\n", buffer);*/
+
+                }
+
                 
-                char temp2[10];
-                sprintf(temp2, "hello");
-                write(socket_tcp, temp2, strlen(temp2)); 
                 /* free memory from local pointers */
                 free(temp);
                 free(buffer_send);

commit 69f04b583a75889f1c6a5e49f5dfc91f6354e1f6
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 19:16:46 2017 -0500

    fix: TCP connection set up.

diff --git a/client/client.c b/client/client.c
index 00c43ad..a607ff6 100644
--- a/client/client.c
+++ b/client/client.c
@@ -28,6 +28,7 @@ Simple TCP/IP echo client.
 /*  Global constants  */
 
 #define MAX_LINE           (1000)
+#define LISTENQ            (1024)  /* Backlog for listen() */
 
 
 /*  Function declarations  */
@@ -230,7 +231,7 @@ int main(int argc, char *argv[]) {
                 /*Create the listening socket  */
 
                 /*Free endptr before using*/
-                free(endptr);
+                /*free(endptr);*/
 
                 tcp_port = strtol(tcpPort, &endptr, 0);
                 if ( *endptr ) {
@@ -248,7 +249,7 @@ int main(int argc, char *argv[]) {
                 /*zero, and fill in the relevant data members   */
 
                 memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
-                servaddr_tcp_udp.sin_family      = AF_INET;
+                servaddr_tcp.sin_family      = AF_INET;
                 servaddr_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
                 servaddr_tcp.sin_port        = htons(tcp_port);
 
@@ -275,11 +276,11 @@ int main(int argc, char *argv[]) {
                     }
 
                     /*Experimental*/
-                    free(buffer);
-                    buffer = (char *) malloc(sizeof(buffer) * MAXLINE);
-                    read(socket_tcp, buffer, MAXLINE);
+                    /*free(buffer);*/
+                    /*buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);*/
+                    /*read(socket_tcp, buffer, MAX_LINE);*/
 
-                    printf("Server responded: %s\n", buffer);
+                    /*printf("Server responded: %s\n", buffer);*/
 
                 }
 
diff --git a/server/server.c b/server/server.c
index 30158db..22ecea3 100644
--- a/server/server.c
+++ b/server/server.c
@@ -40,7 +40,8 @@ int main(int argc, char *argv[]) {
     int       list_s;                /*  listening socket          */
     short int udp_port;                  /*  port number: UDP               */
     short int tcp_port;              /*  port number: TCP          */
-    struct    sockaddr_in servaddr;  /*  socket address structure  */
+    struct    sockaddr_in servaddr_udp;  /*  socket address structure  */
+    struct    sockaddr_in servaddr_tcp;
     struct sockaddr_in remaddr;  /* remote address */
     socklen_t addrlen = sizeof(remaddr); /* length of remote address */
     char     *buffer;      /*  character buffer          */
@@ -68,7 +69,6 @@ int main(int argc, char *argv[]) {
         exit(EXIT_FAILURE);
     }
 
-    /* TCP connection */	
     /*UDP Connection  */
 
     socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
@@ -76,16 +76,16 @@ int main(int argc, char *argv[]) {
     /*  Set all bytes in socket address structure to
         zero, and fill in the relevant data members   */
 
-    memset(&servaddr, 0, sizeof(servaddr));
-    servaddr.sin_family      = AF_INET;
-    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-    servaddr.sin_port        = htons(udp_port);
+    memset(&servaddr_udp, 0, sizeof(servaddr_udp));
+    servaddr_udp.sin_family      = AF_INET;
+    servaddr_udp.sin_addr.s_addr = htonl(INADDR_ANY);
+    servaddr_udp.sin_port        = htons(udp_port);
 
 
     /*  Bind our socket addresss to the 
         listening socket, and call listen()  */
 
-    if ( bind(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
+    if ( bind(socket_udp, (struct sockaddr *) &servaddr_udp, sizeof(servaddr_udp)) < 0 ) {
         fprintf(stderr, "ECHOSERV: Error calling bind()\n");
         exit(EXIT_FAILURE);
     }
@@ -95,7 +95,7 @@ int main(int argc, char *argv[]) {
 
     while ( 1 ) {
         /*UDP connection*/
-        printf("Waiting on port %d\n", port);
+        printf("Waiting on port %d\n", udp_port);
         int recvlen = 0;
         buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
         recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
@@ -170,6 +170,8 @@ int main(int argc, char *argv[]) {
                 token = strtok(NULL, "\n");
             }
 
+            free(token);
+
 
             /*Check if the file exists.*/
             printf("Search file: %s.\n", file_name);
@@ -228,9 +230,41 @@ int main(int argc, char *argv[]) {
                 fclose(fp);
 
                 /*Set up TCP connection*/
-                free(endptr); /*free memory before using. */
-                tcp_port = strtol(
+                /*free(endptr); [>free memory before using. <]*/
+                tcp_port = strtol(string_port, &endptr, 0);
+                /*free(string_port);*/
+
+                if ( *endptr ) {
+                    fprintf(stderr, "ECHOSERV: Invalid port number.\n");
+                    exit(EXIT_FAILURE);
+                }
+
+                printf("tcp_port: %d\n", tcp_port);
+
+                /*  Create the listening socket  */
+
+                if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+                    fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
+                    exit(EXIT_FAILURE);
+                }
+
+                /*Set all bytes in socket address structure to*/
+                /*zero, and fill in the relevant data members   */
 
+                memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
+                servaddr_tcp.sin_family      = AF_INET;
+                servaddr_tcp.sin_port        = htons(tcp_port);
+                servaddr_tcp.sin_addr.s_addr = htnol(INADDR_ANY);
+
+                /*  connect() to the remote echo server  */
+                if ( connect(socket_tcp, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp) ) < 0 ) {
+                    perror("Connection failed");
+                    exit(EXIT_FAILURE);
+                }
+                
+                char temp2[10];
+                sprintf(temp2, "hello");
+                write(socket_tcp, temp2, strlen(temp2)); 
                 /* free memory from local pointers */
                 free(temp);
                 free(buffer_send);
@@ -251,24 +285,12 @@ int main(int argc, char *argv[]) {
                    exit(EXIT_FAILURE);
                }
 
-               /*Free memory from local pointers.*/
-               free(buffer_send);
-               tcp_port = strtol(string_port, &endptr, 0);
-               free(string_port);
-
-               if ( *endptr ) {
-                   fprintf(stderr, "ECHOSERV: Invalid port number.\n");
-                   exit(EXIT_FAILURE);
-               }
-
-               printf("tcp_port: %d\n", tcp_port);
 
             }
 
             free(file_name);
             /*free(tcp_port);*/
             free(endptr);
-            free(buffer);
         }
     }
 }

commit 0a289e84042fbf12180335a96266aeb22f6059f7
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 18:35:42 2017 -0500

    Set up TCP connection in server.

diff --git a/server/server.c b/server/server.c
index a54577b..30158db 100644
--- a/server/server.c
+++ b/server/server.c
@@ -38,7 +38,7 @@ int main(int argc, char *argv[]) {
     int       socket_tcp;                    /*  connection socket                  */
     int	      socket_udp;
     int       list_s;                /*  listening socket          */
-    short int port;                  /*  port number: UDP               */
+    short int udp_port;                  /*  port number: UDP               */
     short int tcp_port;              /*  port number: TCP          */
     struct    sockaddr_in servaddr;  /*  socket address structure  */
     struct sockaddr_in remaddr;  /* remote address */
@@ -55,7 +55,7 @@ int main(int argc, char *argv[]) {
     /*  Get port number from the command line.*/
 
     if ( argc == 2 ) {
-        port = strtol(argv[1], &endptr, 0);
+        udp_port = strtol(argv[1], &endptr, 0);
         if ( *endptr ) {
             fprintf(stderr, "ECHOSERV: Invalid port number.\n");
             exit(EXIT_FAILURE);
@@ -79,7 +79,7 @@ int main(int argc, char *argv[]) {
     memset(&servaddr, 0, sizeof(servaddr));
     servaddr.sin_family      = AF_INET;
     servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-    servaddr.sin_port        = htons(port);
+    servaddr.sin_port        = htons(udp_port);
 
 
     /*  Bind our socket addresss to the 
@@ -146,7 +146,10 @@ int main(int argc, char *argv[]) {
             /*Allocate memory*/
             file_name = (char *) malloc (sizeof(char*) * recvlen);
             /*tcp_port = (s<]hort int *) malloc (sizeof(tcp_port) * 4); [> 4 digits for port number. */
-            endptr = (char *) malloc(sizeof(endptr) * 10);
+
+            /*Temp pointer to hold string tcp port.*/
+            char *string_port;
+            string_port = (char *) malloc(sizeof(string_port) * 10);
             
             char *token; /*for parsing the message into file name and port */
             const char delim = '\n';
@@ -160,7 +163,7 @@ int main(int argc, char *argv[]) {
                 if (position == 1)
                     strcpy(file_name, token);
                 if (position == 2)
-                    strcpy(endptr, token);
+                    strcpy(string_port, token);
                 if (position > 2) 
                     break;
                 position++;
@@ -170,7 +173,7 @@ int main(int argc, char *argv[]) {
 
             /*Check if the file exists.*/
             printf("Search file: %s.\n", file_name);
-            printf("TCP port in string: %s\n", endptr);
+            printf("TCP port in string: %s\n", string_port);
 
             /* Find file name and read that file */
             fp = fopen(file_name, "rb");
@@ -224,6 +227,10 @@ int main(int argc, char *argv[]) {
                 /* close the file and later free the large_buffer */
                 fclose(fp);
 
+                /*Set up TCP connection*/
+                free(endptr); /*free memory before using. */
+                tcp_port = strtol(
+
                 /* free memory from local pointers */
                 free(temp);
                 free(buffer_send);
@@ -246,6 +253,15 @@ int main(int argc, char *argv[]) {
 
                /*Free memory from local pointers.*/
                free(buffer_send);
+               tcp_port = strtol(string_port, &endptr, 0);
+               free(string_port);
+
+               if ( *endptr ) {
+                   fprintf(stderr, "ECHOSERV: Invalid port number.\n");
+                   exit(EXIT_FAILURE);
+               }
+
+               printf("tcp_port: %d\n", tcp_port);
 
             }
 

commit fbd09d6192c5e1d9834cf1c7c02ac22c0ba96e29
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 18:26:21 2017 -0500

    Set up tcp connection in client.

diff --git a/client/client.c b/client/client.c
index 7a74521..00c43ad 100644
--- a/client/client.c
+++ b/client/client.c
@@ -41,9 +41,11 @@ int main(int argc, char *argv[]) {
 
     int       socket_tcp;                    /*  connection socket                  */
     int	      socket_udp;
+    int       list_s;                     /* listening tcp socket */
     short int tcp_port;                   /*  tcp port number                        */
     short int udp_port;                   /*  udp port number                    */
-    struct    sockaddr_in servaddr;       /*  socket address structure           */
+    struct    sockaddr_in servaddr_udp;       /*  socket address structure           */
+    struct    sockaddr_in servaddr_tcp;   /* tcp socket address structre */
     struct    sockaddr_in remaddr;        /*  remote address               	     */
     socklen_t addrlen = sizeof(remaddr);  /*  length of remote address 	     */
     char     *buffer;           /*  character buffer                   */
@@ -67,11 +69,6 @@ int main(int argc, char *argv[]) {
 
     /*  Set the remote port  */
 
-    /*tcp_port = strtol(tcpPort, &endptr, 0);*/
-    /*if ( *endptr ) {*/
-    /*printf("ECHOCLNT: Invalid port supplied.\n");*/
-    /*exit(EXIT_FAILURE);*/
-    /*}*/
 
 
     /*[>  Create the listening socket  <]*/
@@ -84,13 +81,13 @@ int main(int argc, char *argv[]) {
     /*  Set all bytes in socket address structure to*/
     /*zero, and fill in the relevant data members   */
 
-    /*memset(&servaddr, 0, sizeof(servaddr));*/
-    /*servaddr.sin_family      = AF_INET;*/
-    /*servaddr.sin_port        = htons(tcp_port);*/
+    /*memset(&servaddr_udp, 0, sizeof(servaddr_udp));*/
+    /*servaddr_udp.sin_family      = AF_INET;*/
+    /*servaddr_udp.sin_port        = htons(tcp_port);*/
 
     /*[>  Set the remote IP address  <]*/
 
-    /*if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {*/
+    /*if ( inet_aton(szAddress, &servaddr_udp.sin_addr) <= 0 ) {*/
     /*printf("ECHOCLNT: Invalid remote IP address.\n");*/
     /*exit(EXIT_FAILURE);*/
     /*}*/
@@ -98,7 +95,7 @@ int main(int argc, char *argv[]) {
 
     /*[>  connect() to the remote echo server  <]*/
 
-    /*if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {*/
+    /*if ( connect(socket_tcp, (struct sockaddr *) &servaddr_udp, sizeof(servaddr_udp) ) < 0 ) {*/
     /*perror("Connection failed");*/
     /*exit(EXIT_FAILURE);*/
     /*}*/
@@ -123,10 +120,10 @@ int main(int argc, char *argv[]) {
     /*  Set all bytes in socket address structure to
         zero, and fill in the relevant data members   */
 
-    memset(&servaddr, 0, sizeof(servaddr));
-    servaddr.sin_family      = AF_INET;
-    servaddr.sin_port        = htons(udp_port);
-    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    memset(&servaddr_udp, 0, sizeof(servaddr_udp));
+    servaddr_udp.sin_family      = AF_INET;
+    servaddr_udp.sin_port        = htons(udp_port);
+    servaddr_udp.sin_addr.s_addr = htonl(INADDR_ANY);
 
     /*  Get string to follow user commands */
     do {
@@ -151,7 +148,7 @@ int main(int argc, char *argv[]) {
 
             printf("to send length: %d\n", strlen(buffer_send));
             /*Send message to server via UDP*/
-            if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
+            if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr_udp, sizeof(servaddr_udp)) < 0) {
                 perror("Send to, failed.");
                 exit(EXIT_FAILURE);
             }
@@ -199,7 +196,7 @@ int main(int argc, char *argv[]) {
             printf("to be send len: %d\n", strlen(buffer_send));
 
             /* Send message to server. */
-            if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
+            if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr_udp, sizeof(servaddr_udp)) < 0) {
                 perror("Send to, failed.");
                 exit(EXIT_FAILURE);
             }
@@ -225,9 +222,67 @@ int main(int argc, char *argv[]) {
             temp = (char *) malloc(sizeof(temp) * MAX_LINE);
             strncpy(temp, buffer, strlen(buffer) - 1);
 
-            /*If file doesn't exist.*/
+            /*If file does exist.*/
             if (strcmp(status_token, "OK") == 0) {
                 printf("Transfer started....\n");
+                
+                /*Set up TCP connection*/
+                /*Create the listening socket  */
+
+                /*Free endptr before using*/
+                free(endptr);
+
+                tcp_port = strtol(tcpPort, &endptr, 0);
+                if ( *endptr ) {
+                    printf("ECHOCLNT: Invalid port supplied.\n");
+                    exit(EXIT_FAILURE);
+                }
+                if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+                    perror("ECHOSERV: Error creating listening socket.\n");
+
+                    exit(EXIT_FAILURE);
+                }
+
+
+                /*Set all bytes in socket address structure to*/
+                /*zero, and fill in the relevant data members   */
+
+                memset(&servaddr_tcp, 0, sizeof(servaddr_tcp));
+                servaddr_tcp_udp.sin_family      = AF_INET;
+                servaddr_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
+                servaddr_tcp.sin_port        = htons(tcp_port);
+
+
+                /*Bind our socket addresss to the */
+                /*listening socket, and call listen()  */
+
+                if ( bind(list_s, (struct sockaddr *) &servaddr_tcp, sizeof(servaddr_tcp)) < 0 ) {
+                    fprintf(stderr, "ECHOSERV: Error calling bind()\n");
+                    exit(EXIT_FAILURE);
+                }
+
+                if ( listen(list_s, LISTENQ) < 0 ) {
+                    perror("ECHOSERV: Error calling listen()\n");
+                    exit(EXIT_FAILURE);
+                }
+
+                while (1) {
+                    /*Wait for a connection, then accept() it  */
+
+                    if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {
+                        perror("Error in calling accept():");
+                        exit(EXIT_FAILURE);
+                    }
+
+                    /*Experimental*/
+                    free(buffer);
+                    buffer = (char *) malloc(sizeof(buffer) * MAXLINE);
+                    read(socket_tcp, buffer, MAXLINE);
+
+                    printf("Server responded: %s\n", buffer);
+
+                }
+
             }
             else {
                 printf("%s not found.\n", temp);
@@ -247,10 +302,11 @@ int main(int argc, char *argv[]) {
             /*fclose(fp);*/
 
             /*Free memory*/
-            free(file_name);
             free(buffer);
-            free(buffer_send);
             free(buffer_received);
+            free(buffer_send);
+            free(file_name);
+            free(temp);
         }
             else if (strncmp(buffer, "q", 1) == 0) {
                 fprintf(stderr, "Now should exit.\n");
diff --git a/server/server.c b/server/server.c
index edbd7e4..a54577b 100644
--- a/server/server.c
+++ b/server/server.c
@@ -69,37 +69,6 @@ int main(int argc, char *argv[]) {
     }
 
     /* TCP connection */	
-    /*  Create the listening socket  */
-
-    /* if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
-    /*perror("ECHOSERV: Error creating listening socket.\n");*/
-
-    /*exit(EXIT_FAILURE);*/
-    /*}*/
-
-
-    /*  Set all bytes in socket address structure to*/
-    /*zero, and fill in the relevant data members   */
-
-    /*memset(&servaddr, 0, sizeof(servaddr));*/
-    /*servaddr.sin_family      = AF_INET;*/
-    /*servaddr.sin_addr.s_addr = htonl(INADDR_ANY);*/
-    /*servaddr.sin_port        = htons(port);*/
-
-
-    /*  Bind our socket addresss to the */
-    /*listening socket, and call listen()  */
-
-    /*if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {*/
-    /*fprintf(stderr, "ECHOSERV: Error calling bind()\n");*/
-    /*exit(EXIT_FAILURE);*/
-    /*}*/
-
-    /*if ( listen(list_s, LISTENQ) < 0 ) {*/
-    /*perror("ECHOSERV: Error calling listen()\n");*/
-    /*exit(EXIT_FAILURE);*/
-    /*}*/
-
     /*UDP Connection  */
 
     socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
@@ -136,13 +105,6 @@ int main(int argc, char *argv[]) {
             printf("received message: \"%s\"\n", buffer);
         }
         printf("buffer len: %d\n.", strlen(buffer));
-        /*  Wait for a connection, then accept() it  */
-
-        /*         if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {*/
-        /*fprintf(stderr, "ECHOSERV: Error calling accept()\n");*/
-        /*exit(EXIT_FAILURE);*/
-        /*}*/
-
 
         if (strncmp(buffer, "CAP", 3) == 0) {
             /*number of relevant bytes of message */

commit a1e7645e1f7ac24eac0db786fc91f866b152485d
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 17:48:05 2017 -0500

    fix: format 'not found' message.

diff --git a/client/client.c b/client/client.c
index 96fbd06..7a74521 100644
--- a/client/client.c
+++ b/client/client.c
@@ -55,6 +55,7 @@ int main(int argc, char *argv[]) {
     char     *endptr;                     /*  for strtol()                       */
     FILE     *fp;                         /*  file pointer                       */
     char     *file_name;                  /*  for creating and writing data into */
+    char     *temp;                       /*  temp storage, for formatting/printing */
 
 
     /*  Get command line arguments  */
@@ -220,12 +221,16 @@ int main(int argc, char *argv[]) {
             status_token = strtok(status_token, "\n");
             printf("status?: %s\n", status_token);
 
+            /*Holds file name without new line character.*/
+            temp = (char *) malloc(sizeof(temp) * MAX_LINE);
+            strncpy(temp, buffer, strlen(buffer) - 1);
+
             /*If file doesn't exist.*/
-            if (strcmp(status_token, "OK")) {
+            if (strcmp(status_token, "OK") == 0) {
                 printf("Transfer started....\n");
             }
             else {
-                printf("%s not found.\n", buffer);
+                printf("%s not found.\n", temp);
             }
 
 

commit 66df8bd9a15a70631f45ed2f68279cbc974894eb
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 17:28:21 2017 -0500

    Implement displaying 'filename not found.' message.

diff --git a/client/client.c b/client/client.c
index a6e08a4..96fbd06 100644
--- a/client/client.c
+++ b/client/client.c
@@ -220,6 +220,16 @@ int main(int argc, char *argv[]) {
             status_token = strtok(status_token, "\n");
             printf("status?: %s\n", status_token);
 
+            /*If file doesn't exist.*/
+            if (strcmp(status_token, "OK")) {
+                printf("Transfer started....\n");
+            }
+            else {
+                printf("%s not found.\n", buffer);
+            }
+
+
+
             /*[> write the data to the file. <]*/
             /*if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {*/
             /*printf("Server responded: %s\n", buffer_received + 2);*/

commit f68a85fc0031d52c1516b0175d8af6676647371c
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 16:52:29 2017 -0500

    Parse the status of file sent by server.

diff --git a/client/client.c b/client/client.c
index 2778627..a6e08a4 100644
--- a/client/client.c
+++ b/client/client.c
@@ -213,8 +213,12 @@ int main(int argc, char *argv[]) {
                 printf("Server responded: %s\n", buffer_received);
             }
 
-            /*[> Read message from server. <]*/
-            /*read(socket_tcp, buffer_received, MAX_LINE-1);*/
+
+            /*Check status of file from server.*/
+            char *status_token = (char *) malloc(sizeof(status_token) * MAX_LINE);
+            strcpy(status_token, buffer_received);
+            status_token = strtok(status_token, "\n");
+            printf("status?: %s\n", status_token);
 
             /*[> write the data to the file. <]*/
             /*if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {*/

commit dd908f6abc468bbf5cc574ee2ee3dc47586fa081
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 16:26:50 2017 -0500

    Implement informing inexistence of file to client.

diff --git a/server/server.c b/server/server.c
index df6480b..edbd7e4 100644
--- a/server/server.c
+++ b/server/server.c
@@ -241,7 +241,7 @@ int main(int argc, char *argv[]) {
                 printf("stats ok mesg: %s\n", buffer_send); /*debug*/
 
                 /*Send Status message to client.*/
-                if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen)) < 0) {
+                if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen) < 0) {
                     perror("Failed to send status.");
                     exit(EXIT_FAILURE);
                 }
@@ -267,6 +267,25 @@ int main(int argc, char *argv[]) {
                 free(buffer_send);
                 free(large_buffer);
             }
+            else {
+                /*Inform client that file doesn't exist*/
+               buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
+               strcpy(buffer_send, "NOT FOUND\n");
+
+               printf("to send: %s\n", buffer_send);
+               printf("to send len: %d\n", strlen(buffer_send));
+
+               /*Send message to client.*/
+               
+               if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen) < 0) {
+                   perror("Failed to send no file status.");
+                   exit(EXIT_FAILURE);
+               }
+
+               /*Free memory from local pointers.*/
+               free(buffer_send);
+
+            }
 
             free(file_name);
             /*free(tcp_port);*/

commit 374bd77c09d5cc443479d378c29a7d8e6a48517c
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 16:08:16 2017 -0500

    fix: send to right client address from server.

diff --git a/client/client.c b/client/client.c
index 82fc95c..2778627 100644
--- a/client/client.c
+++ b/client/client.c
@@ -205,7 +205,7 @@ int main(int argc, char *argv[]) {
 
             /*Recieve status from server.*/
             int recvlen = 0;
-            buffer_reeived = (char *) malloc(sizeof(buffer_received) * MAX_LINE);
+            buffer_received = (char *) malloc(sizeof(buffer_received) * MAX_LINE);
             recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
             if (recvlen > 0) {
                 buffer_received[recvlen] = '\0';
@@ -231,6 +231,7 @@ int main(int argc, char *argv[]) {
             free(file_name);
             free(buffer);
             free(buffer_send);
+            free(buffer_received);
         }
             else if (strncmp(buffer, "q", 1) == 0) {
                 fprintf(stderr, "Now should exit.\n");
diff --git a/server/server.c b/server/server.c
index c16bad4..df6480b 100644
--- a/server/server.c
+++ b/server/server.c
@@ -241,7 +241,7 @@ int main(int argc, char *argv[]) {
                 printf("stats ok mesg: %s\n", buffer_send); /*debug*/
 
                 /*Send Status message to client.*/
-                if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
+                if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen)) < 0) {
                     perror("Failed to send status.");
                     exit(EXIT_FAILURE);
                 }

commit 84a1aa128ba64fb40d21c5f5b1059e222ae92a2f
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 16:03:36 2017 -0500

    Implement communication file exist status between client and server.

diff --git a/client/client.c b/client/client.c
index 9d339b4..82fc95c 100644
--- a/client/client.c
+++ b/client/client.c
@@ -203,6 +203,16 @@ int main(int argc, char *argv[]) {
                 exit(EXIT_FAILURE);
             }
 
+            /*Recieve status from server.*/
+            int recvlen = 0;
+            buffer_reeived = (char *) malloc(sizeof(buffer_received) * MAX_LINE);
+            recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
+            if (recvlen > 0) {
+                buffer_received[recvlen] = '\0';
+                printf("total bytest received: %d.\n", recvlen);
+                printf("Server responded: %s\n", buffer_received);
+            }
+
             /*[> Read message from server. <]*/
             /*read(socket_tcp, buffer_received, MAX_LINE-1);*/
 
diff --git a/server/server.c b/server/server.c
index 374cab9..c16bad4 100644
--- a/server/server.c
+++ b/server/server.c
@@ -204,25 +204,7 @@ int main(int argc, char *argv[]) {
                 position++;
                 token = strtok(NULL, "\n");
             }
-                
-            /*Null terminate the string.*/
-            file_name[strlen(buffer) + 5 - (recvlen - 11)] = '\0';
-
-            /*Experiment*/
-            /*int linebrk_counter = 0;*/
-            /*int offset = 0;*/
-            /*while (offset < recvlen) {*/
-                /*if (strcmp(buffer + offset, "\n") == 0) {*/
-                    /*linebrk_counter++; */
-                    /*printf("line broke up!! :(");*/
-                /*}*/
-                /*if (linebrk_counter == 1) {*/
-                    /*continue;*/
-                /*}*/
-                /*if (linebrk_counter >= 2)*/
-                    /*break;*/
-                /*offset++;*/
-            /*}*/
+
 
             /*Check if the file exists.*/
             printf("Search file: %s.\n", file_name);
@@ -250,7 +232,7 @@ int main(int argc, char *argv[]) {
                 temp = (char *) malloc(sizeof(temp) * MAX_LINE);
                 buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
                
-                /*sprintf(temp, "%d", lSize);*/
+                sprintf(temp, "%Ld", lSize);
                 printf("size of file: %Ld\n", lSize);
                 strcpy(buffer_send, "OK\n");
                 strcat(buffer_send, temp);
@@ -258,6 +240,12 @@ int main(int argc, char *argv[]) {
 
                 printf("stats ok mesg: %s\n", buffer_send); /*debug*/
 
+                /*Send Status message to client.*/
+                if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
+                    perror("Failed to send status.");
+                    exit(EXIT_FAILURE);
+                }
+
 
                 /* allocate memory to hold the whole file */
                 large_buffer = (void* ) malloc(sizeof(void*) * lSize);

commit 02436c5654c4050e50d34931bf935f33600424ba
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 15:54:02 2017 -0500

    Use strtok to parse the message into file name and port.

diff --git a/server/server.c b/server/server.c
index c3f97e3..374cab9 100644
--- a/server/server.c
+++ b/server/server.c
@@ -185,18 +185,54 @@ int main(int argc, char *argv[]) {
             file_name = (char *) malloc (sizeof(char*) * recvlen);
             /*tcp_port = (s<]hort int *) malloc (sizeof(tcp_port) * 4); [> 4 digits for port number. */
             endptr = (char *) malloc(sizeof(endptr) * 10);
-
-            /*file_name is in the range [buffer[5], buffer[buffer_len - 5]*/
-            strncpy(file_name, buffer + 5, recvlen - 10);
-            strncpy(endptr, buffer + (strlen(buffer) - 5), 4);
+            
+            char *token; /*for parsing the message into file name and port */
+            const char delim = '\n';
+            token = (char *) malloc(sizeof(token) * strlen(buffer)+1);
+            strcpy(token, buffer);
+            token = strtok(token, "\n"); 
+
+            /*Walk through other tokens.*/
+            int position = 0; /* Position: 1 = FILE, 2 = <file name>, 3 = TCP port */
+            while (token != NULL) {
+                if (position == 1)
+                    strcpy(file_name, token);
+                if (position == 2)
+                    strcpy(endptr, token);
+                if (position > 2) 
+                    break;
+                position++;
+                token = strtok(NULL, "\n");
+            }
+                
+            /*Null terminate the string.*/
+            file_name[strlen(buffer) + 5 - (recvlen - 11)] = '\0';
+
+            /*Experiment*/
+            /*int linebrk_counter = 0;*/
+            /*int offset = 0;*/
+            /*while (offset < recvlen) {*/
+                /*if (strcmp(buffer + offset, "\n") == 0) {*/
+                    /*linebrk_counter++; */
+                    /*printf("line broke up!! :(");*/
+                /*}*/
+                /*if (linebrk_counter == 1) {*/
+                    /*continue;*/
+                /*}*/
+                /*if (linebrk_counter >= 2)*/
+                    /*break;*/
+                /*offset++;*/
+            /*}*/
 
             /*Check if the file exists.*/
+            printf("Search file: %s.\n", file_name);
+            printf("TCP port in string: %s\n", endptr);
 
             /* Find file name and read that file */
             fp = fopen(file_name, "rb");
             if (fp) {
                
-                printf("Do you even go here?");
+                printf("Do you even go here?\n");
                 /*Read the file and file size.*/
                 long lSize;
                 void* large_buffer;
@@ -211,15 +247,16 @@ int main(int argc, char *argv[]) {
                 
                 /*Format status message.*/
                
-                temp = (char *) malloc(sizeof(temp) * lSize);
+                temp = (char *) malloc(sizeof(temp) * MAX_LINE);
                 buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
                
-                sprintf(temp, "%l", lSize);
+                /*sprintf(temp, "%d", lSize);*/
+                printf("size of file: %Ld\n", lSize);
                 strcpy(buffer_send, "OK\n");
                 strcat(buffer_send, temp);
                 strcat(buffer_send, "\n");
 
-                printf("stats ok mesg: %s", buffer_send);
+                printf("stats ok mesg: %s\n", buffer_send); /*debug*/
 
 
                 /* allocate memory to hold the whole file */
@@ -237,11 +274,16 @@ int main(int argc, char *argv[]) {
                 /* close the file and later free the large_buffer */
                 fclose(fp);
 
-                free(file_name);
-                /*free(tcp_port);*/
-                free(endptr);
-                free(buffer);
+                /* free memory from local pointers */
+                free(temp);
+                free(buffer_send);
+                free(large_buffer);
             }
+
+            free(file_name);
+            /*free(tcp_port);*/
+            free(endptr);
+            free(buffer);
         }
     }
 }

commit fea91603aa535fd55c10dc36a2555a9f245772a5
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 14:27:55 2017 -0500

    Check if the filename exists in the server.

diff --git a/server/server.c b/server/server.c
index b1e83cc..c3f97e3 100644
--- a/server/server.c
+++ b/server/server.c
@@ -48,7 +48,7 @@ int main(int argc, char *argv[]) {
     char     *endptr;                /*  for strtol()              */
     char     *to_capitalize;         /*  store user string to capitalize */
     char     *file_name;             /*  for storing file_name to be searched in the server */
-    char     *temp                   /*  for temporary storage of strings; for formatting */
+    char     *temp;                   /*  for temporary storage of strings; for formatting */
     FILE     *fp;                    /*  file pointer */
 
 
@@ -196,7 +196,7 @@ int main(int argc, char *argv[]) {
             fp = fopen(file_name, "rb");
             if (fp) {
                
-
+                printf("Do you even go here?");
                 /*Read the file and file size.*/
                 long lSize;
                 void* large_buffer;
@@ -242,6 +242,9 @@ int main(int argc, char *argv[]) {
                 free(endptr);
                 free(buffer);
             }
+        }
+    }
+}
 
             /*[> send the buffer to the client <]*/
             /*if (MAX_LINE < lSize) {*/
@@ -281,5 +284,4 @@ int main(int argc, char *argv[]) {
             /*else {*/
             /*fprintf(stderr, "Connection closed.\n");*/
             /*}*/
-}
-}
+

commit 7e486d1779e44c2a6a487860e1f2203f7eedd71a
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 14:21:26 2017 -0500

    Format status OK message to be sent to client.

diff --git a/server/server.c b/server/server.c
index 8c77d21..b1e83cc 100644
--- a/server/server.c
+++ b/server/server.c
@@ -48,6 +48,7 @@ int main(int argc, char *argv[]) {
     char     *endptr;                /*  for strtol()              */
     char     *to_capitalize;         /*  store user string to capitalize */
     char     *file_name;             /*  for storing file_name to be searched in the server */
+    char     *temp                   /*  for temporary storage of strings; for formatting */
     FILE     *fp;                    /*  file pointer */
 
 
@@ -181,83 +182,104 @@ int main(int argc, char *argv[]) {
         if (strncmp(buffer, "FILE", 4) == 0) {
 
             /*Allocate memory*/
-            file_name = /*(char *) malloc (sizeof(char*) * recvlen);*/
+            file_name = (char *) malloc (sizeof(char*) * recvlen);
             /*tcp_port = (s<]hort int *) malloc (sizeof(tcp_port) * 4); [> 4 digits for port number. */
             endptr = (char *) malloc(sizeof(endptr) * 10);
 
-
+            /*file_name is in the range [buffer[5], buffer[buffer_len - 5]*/
+            strncpy(file_name, buffer + 5, recvlen - 10);
             strncpy(endptr, buffer + (strlen(buffer) - 5), 4);
-            printf("chusyo tcp_port?: %s", tcp_port);
-            
-            /*free(file_name);*/
-            /*free(tcp_port);*/
-            free(endptr);
-            free(buffer);
-        }
-        /*[> Find file name and read that file <]*/
-        /*fp = fopen(file_name, "rb");*/
-        /*if (fp) {*/
-        /*long lSize;*/
-        /*void* large_buffer;*/
-        /*size_t result;*/
-
-        /*[> obtain file size <]*/
-        /*fseek(fp, 0, SEEK_END);*/
-        /*lSize = ftell(fp);*/
-        /*rewind(fp); [> Put the postion of pointer back to the start of the file <]*/
-
-        /*[> allocate memory to hold the whole file <]*/
-        /*large_buffer = (void* ) malloc(sizeof(void*) * lSize);*/
-        /*if (large_buffer == NULL) {*/
-        /*perror("Error in allocating required memory: ");*/
-        /*}*/
 
-        /*[> copy the file into the buffer <]*/
-        /*result = fread(large_buffer, 1, lSize, fp);*/
-        /*if (result != lSize) {*/
-        /*printf("Error reading whole file.\n");*/
-        /*}*/
+            /*Check if the file exists.*/
+
+            /* Find file name and read that file */
+            fp = fopen(file_name, "rb");
+            if (fp) {
+               
+
+                /*Read the file and file size.*/
+                long lSize;
+                void* large_buffer;
+                size_t result;
+
+                /* obtain file size */
+                fseek(fp, 0, SEEK_END);
+                lSize = ftell(fp);
+                rewind(fp); /* Put the postion of pointer back to the start of the file */
+                
+                /*Inform client that file exists.*/
+                
+                /*Format status message.*/
+               
+                temp = (char *) malloc(sizeof(temp) * lSize);
+                buffer_send = (char *) malloc(sizeof(buffer_send) * MAX_LINE);
+               
+                sprintf(temp, "%l", lSize);
+                strcpy(buffer_send, "OK\n");
+                strcat(buffer_send, temp);
+                strcat(buffer_send, "\n");
+
+                printf("stats ok mesg: %s", buffer_send);
+
+
+                /* allocate memory to hold the whole file */
+                large_buffer = (void* ) malloc(sizeof(void*) * lSize);
+                if (large_buffer == NULL) {
+                    perror("Error in allocating required memory: ");
+                }
 
-        /*[> close the file and later free the large_buffer <]*/
-        /*fclose(fp);*/
+                /* copy the file into the buffer */
+                result = fread(large_buffer, 1, lSize, fp);
+                if (result != lSize) {
+                    printf("Error reading whole file.\n");
+                }
 
-        /*[> send the buffer to the client <]*/
-        /*if (MAX_LINE < lSize) {*/
-        /*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
-        /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-        /*}*/
-        /*else {*/
-        /*sprintf(buffer_send, "%d", lSize);*/
-        /*strcat(buffer_send, "\n");*/
-        /*strcat(buffer_send, large_buffer);*/
-        /*write(socket_tcp, buffer_send, lSize);*/
-        /*}*/
+                /* close the file and later free the large_buffer */
+                fclose(fp);
 
-        /*[> free the memory <]*/
-        /*free(large_buffer);*/
-        /*free(file_name);*/
-        /*} else {*/
-        /*[> No such file <]*/
-        /*strcpy(buffer, "NOT FOUND");*/
-        /*sprintf(buffer_send, "%d", strlen(buffer));*/
-        /*strcat(buffer_send, "\n");*/
-        /*strcat(buffer_send, buffer);*/
-
-        /*[> Inform client that file is not in the server. <]*/
-        /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-        /*}*/
-
-        /*}*/
+                free(file_name);
+                /*free(tcp_port);*/
+                free(endptr);
+                free(buffer);
+            }
 
-        /*   [>* free the memory */
+            /*[> send the buffer to the client <]*/
+            /*if (MAX_LINE < lSize) {*/
+            /*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
+            /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+            /*}*/
+            /*else {*/
+            /*sprintf(buffer_send, "%d", lSize);*/
+            /*strcat(buffer_send, "\n");*/
+            /*strcat(buffer_send, large_buffer);*/
+            /*write(socket_tcp, buffer_send, lSize);*/
+            /*}*/
 
-        /*  Close the connected socket  */
-        /*         if ( close(socket_tcp) < 0 ) {*/
-        /*perror("ECHOSERV: Error calling close()\n");*/
-        /*exit(EXIT_FAILURE);*/
-        /*}*/
-        /*else {*/
-        /*fprintf(stderr, "Connection closed.\n");*/
-        /*}*/
-    }
+            /*[> free the memory <]*/
+            /*free(large_buffer);*/
+            /*free(file_name);*/
+            /*} else {*/
+            /*[> No such file <]*/
+            /*strcpy(buffer, "NOT FOUND");*/
+            /*sprintf(buffer_send, "%d", strlen(buffer));*/
+            /*strcat(buffer_send, "\n");*/
+            /*strcat(buffer_send, buffer);*/
+
+            /*[> Inform client that file is not in the server. <]*/
+            /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+            /*}*/
+
+            /*}*/
+
+            /*   [>* free the memory */
+
+            /*  Close the connected socket  */
+            /*         if ( close(socket_tcp) < 0 ) {*/
+            /*perror("ECHOSERV: Error calling close()\n");*/
+            /*exit(EXIT_FAILURE);*/
+            /*}*/
+            /*else {*/
+            /*fprintf(stderr, "Connection closed.\n");*/
+            /*}*/
+}
 }

commit 5846e7647614add336b0caffe8c7d223efb7f053
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 13:46:57 2017 -0500

    Extract tcp port from the message by client.

diff --git a/server/server.c b/server/server.c
index 0fe20c7..8c77d21 100644
--- a/server/server.c
+++ b/server/server.c
@@ -179,13 +179,19 @@ int main(int argc, char *argv[]) {
         }
 
         if (strncmp(buffer, "FILE", 4) == 0) {
-            file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer)));
-            tcp_port = (short int *) malloc (sizeof(tcp_port) * 4); /* 4 digits for port number. */
+
+            /*Allocate memory*/
+            file_name = /*(char *) malloc (sizeof(char*) * recvlen);*/
+            /*tcp_port = (s<]hort int *) malloc (sizeof(tcp_port) * 4); [> 4 digits for port number. */
+            endptr = (char *) malloc(sizeof(endptr) * 10);
+
+
             strncpy(endptr, buffer + (strlen(buffer) - 5), 4);
             printf("chusyo tcp_port?: %s", tcp_port);
             
-            free(file_name);
-            free(tcp_port);
+            /*free(file_name);*/
+            /*free(tcp_port);*/
+            free(endptr);
             free(buffer);
         }
         /*[> Find file name and read that file <]*/

commit 72fb8f0c1c6644407a450b11122ed6c17941678d
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 13:39:48 2017 -0500

    fix: add new line to the message containing file name.

diff --git a/client/client.c b/client/client.c
index cf2fe39..9d339b4 100644
--- a/client/client.c
+++ b/client/client.c
@@ -191,9 +191,9 @@ int main(int argc, char *argv[]) {
             printf("before port is attached: %s", buffer_send);
             
             strcat(buffer_send, tcpPort);
+            strcat(buffer_send, "\n");
 
             /*Debug*/
-            printf("tcp port: %d\n", tcp_port);
             printf("to be send: %s\n", buffer_send);
             printf("to be send len: %d\n", strlen(buffer_send));
 
diff --git a/server/server.c b/server/server.c
index 243f516..0fe20c7 100644
--- a/server/server.c
+++ b/server/server.c
@@ -169,7 +169,7 @@ int main(int argc, char *argv[]) {
             int sentlen = 0;
 
             /*strlen doesn't return the length including null terminator.*/
-            sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize) + 1, 0, (struct sockaddr *) &remaddr, addrlen);
+            sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize), 0, (struct sockaddr *) &remaddr, addrlen);
             if (sentlen < 0) {
                 perror("Sending failed.");
             }
@@ -181,10 +181,12 @@ int main(int argc, char *argv[]) {
         if (strncmp(buffer, "FILE", 4) == 0) {
             file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer)));
             tcp_port = (short int *) malloc (sizeof(tcp_port) * 4); /* 4 digits for port number. */
-            strncpy(tcp_port, buffer + (strlen(buffer) - 5), 4);
+            strncpy(endptr, buffer + (strlen(buffer) - 5), 4);
             printf("chusyo tcp_port?: %s", tcp_port);
             
-            
+            free(file_name);
+            free(tcp_port);
+            free(buffer);
         }
         /*[> Find file name and read that file <]*/
         /*fp = fopen(file_name, "rb");*/

commit fcad3bc9ac544366e82e80c53b5f1805db1d5ea6
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 13:24:45 2017 -0500

    Extract tcp port number from the message buffer.

diff --git a/server/server.c b/server/server.c
index a83c286..243f516 100644
--- a/server/server.c
+++ b/server/server.c
@@ -39,6 +39,7 @@ int main(int argc, char *argv[]) {
     int	      socket_udp;
     int       list_s;                /*  listening socket          */
     short int port;                  /*  port number: UDP               */
+    short int tcp_port;              /*  port number: TCP          */
     struct    sockaddr_in servaddr;  /*  socket address structure  */
     struct sockaddr_in remaddr;  /* remote address */
     socklen_t addrlen = sizeof(remaddr); /* length of remote address */
@@ -165,9 +166,10 @@ int main(int argc, char *argv[]) {
             printf("to send: %s\n", to_capitalize);
             printf("to send length: %d\n", strlen(to_capitalize));
             /*[> send the formatted message to the client <]*/
-            /*Add null char at the end*/
             int sentlen = 0;
-            sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize), 0, (struct sockaddr *) &remaddr, addrlen);
+
+            /*strlen doesn't return the length including null terminator.*/
+            sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize) + 1, 0, (struct sockaddr *) &remaddr, addrlen);
             if (sentlen < 0) {
                 perror("Sending failed.");
             }
@@ -178,7 +180,11 @@ int main(int argc, char *argv[]) {
 
         if (strncmp(buffer, "FILE", 4) == 0) {
             file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer)));
-
+            tcp_port = (short int *) malloc (sizeof(tcp_port) * 4); /* 4 digits for port number. */
+            strncpy(tcp_port, buffer + (strlen(buffer) - 5), 4);
+            printf("chusyo tcp_port?: %s", tcp_port);
+            
+            
         }
         /*[> Find file name and read that file <]*/
         /*fp = fopen(file_name, "rb");*/

commit 7dcfd4d4c484c54094abdbf1c72fbc248ff8365f
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 13:10:43 2017 -0500

    Implement concatenating tcp port number to message including file name.

diff --git a/client/client.c b/client/client.c
index 5565b50..cf2fe39 100644
--- a/client/client.c
+++ b/client/client.c
@@ -180,18 +180,22 @@ int main(int argc, char *argv[]) {
             printf("\nPlease Enter a string: ");
             fgets(buffer, MAX_LINE, stdin);
 
-           file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
-           strncpy(file_name, buffer, strlen(buffer) - 1);
+            file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
+            strncpy(file_name, buffer, strlen(buffer) - 1);
 
-           buffer_send = (char *) malloc(sizeof(buffer_send) * strlen(buffer) + 10);
+            buffer_send = (char *) malloc(sizeof(buffer_send) * strlen(buffer) + 10);
 
             /*Format the input string */
             strcpy(buffer_send, "FILE\n");
             strcat(buffer_send, buffer);
-            sprintf(buffer_send, "%d", tcp_port);
+            printf("before port is attached: %s", buffer_send);
+            
+            strcat(buffer_send, tcpPort);
 
-            printf("to be send: %s", buffer_send);
-            printf("to be send len: %d", strlen(buffer_send));
+            /*Debug*/
+            printf("tcp port: %d\n", tcp_port);
+            printf("to be send: %s\n", buffer_send);
+            printf("to be send len: %d\n", strlen(buffer_send));
 
             /* Send message to server. */
             if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
@@ -218,35 +222,35 @@ int main(int argc, char *argv[]) {
             free(buffer);
             free(buffer_send);
         }
-        else if (strncmp(buffer, "q", 1) == 0) {
-            fprintf(stderr, "Now should exit.\n");
-            if (close(socket_tcp) < 0 ) {
-                fprintf(stderr, "ECHOSERV: Error calling close()\n");
-                exit(EXIT_FAILURE);
+            else if (strncmp(buffer, "q", 1) == 0) {
+                fprintf(stderr, "Now should exit.\n");
+                if (close(socket_tcp) < 0 ) {
+                    fprintf(stderr, "ECHOSERV: Error calling close()\n");
+                    exit(EXIT_FAILURE);
+                }
+
+                return EXIT_SUCCESS;
             }
+            else 
+                printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
+        } while (strncmp(buffer, "q", 1) != 0);
 
-            return EXIT_SUCCESS;
-        }
-        else 
-            printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
-    } while (strncmp(buffer, "q", 1) != 0);
-
-    return EXIT_SUCCESS;
-}
+        return EXIT_SUCCESS;
+    }
 
 
-int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort) {
-    /* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
-    if (argc == 4) {
-        *tcpPort = argv[1];
-        *szAddress = argv[2];
-        *udpPort = argv[3];
-    }
-    else {
-        printf("Usage:\n\n");
-        printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
-        exit(EXIT_SUCCESS);
+    int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort) {
+        /* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
+        if (argc == 4) {
+            *tcpPort = argv[1];
+            *szAddress = argv[2];
+            *udpPort = argv[3];
+        }
+        else {
+            printf("Usage:\n\n");
+            printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
+            exit(EXIT_SUCCESS);
+        }
+        return 0;
     }
-    return 0;
-}
 
diff --git a/server/server.c b/server/server.c
index ba874f9..a83c286 100644
--- a/server/server.c
+++ b/server/server.c
@@ -178,8 +178,8 @@ int main(int argc, char *argv[]) {
 
         if (strncmp(buffer, "FILE", 4) == 0) {
             file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer)));
-            memcpy(file_name, buffer + 5, strlen(buffer) - 6);
 
+        }
         /*[> Find file name and read that file <]*/
         /*fp = fopen(file_name, "rb");*/
         /*if (fp) {*/

commit 0877c9e7ecc49bde85a3537aa53af3c1e39a0c13
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 02:56:46 2017 -0500

    Parse message containing file name.

diff --git a/client/client.c b/client/client.c
index 08c8b6e..5565b50 100644
--- a/client/client.c
+++ b/client/client.c
@@ -188,6 +188,10 @@ int main(int argc, char *argv[]) {
             /*Format the input string */
             strcpy(buffer_send, "FILE\n");
             strcat(buffer_send, buffer);
+            sprintf(buffer_send, "%d", tcp_port);
+
+            printf("to be send: %s", buffer_send);
+            printf("to be send len: %d", strlen(buffer_send));
 
             /* Send message to server. */
             if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
diff --git a/server/server.c b/server/server.c
index ef81fe7..ba874f9 100644
--- a/server/server.c
+++ b/server/server.c
@@ -176,9 +176,9 @@ int main(int argc, char *argv[]) {
             free(buffer);
         }
 
-        /*if (strncmp(buffer, "FILE", 4) == 0) {*/
-        /*file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));*/
-        /*memcpy(file_name, buffer + 5, strlen(buffer) - 6);*/
+        if (strncmp(buffer, "FILE", 4) == 0) {
+            file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer)));
+            memcpy(file_name, buffer + 5, strlen(buffer) - 6);
 
         /*[> Find file name and read that file <]*/
         /*fp = fopen(file_name, "rb");*/

commit 1a201cac150ac1fc2020d449e24572258bd49de8
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 02:28:45 2017 -0500

    Implement sending file name to server

diff --git a/client/client.c b/client/client.c
index 32bb839..08c8b6e 100644
--- a/client/client.c
+++ b/client/client.c
@@ -137,17 +137,17 @@ int main(int argc, char *argv[]) {
             /*Reset buffer to get the string.*/
             free(buffer);
             buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
-            
+
             printf("\nPlease Enter a string: ");
             fgets(buffer, MAX_LINE, stdin);
-           
+
             /*CAP + 2 new lines + null terminator = 6*/
             buffer_send =  (char *) malloc(sizeof(buffer_send) * (strlen(buffer))); 
             printf("size of buffer: %d\n", strlen(buffer));
             /* Format the input string */
             strcpy(buffer_send, "CAP\n");
             strcat(buffer_send, buffer);
-            
+
             printf("to send length: %d\n", strlen(buffer_send));
             /*Send message to server via UDP*/
             if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
@@ -173,18 +173,27 @@ int main(int argc, char *argv[]) {
             /*printf("Server responded: %s", buffer);*/
         }
         else if (strncmp(buffer, "t", 1) == 0) {
-        /*    printf("\nPlease Enter a string: ");*/
-            /*fgets(buffer, MAX_LINE, stdin);*/
+            /*Reset buffer to get the string.*/
+            free(buffer);
+            buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
 
-            /*file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));*/
-            /*memcpy(file_name, buffer, strlen(buffer) - 1);  */
+            printf("\nPlease Enter a string: ");
+            fgets(buffer, MAX_LINE, stdin);
 
-            /* Format the input string */
-          /*  strcpy(buffer_send, "FILE\n");*/
-            /*strcat(buffer_send, buffer);*/
+           file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
+           strncpy(file_name, buffer, strlen(buffer) - 1);
+
+           buffer_send = (char *) malloc(sizeof(buffer_send) * strlen(buffer) + 10);
+
+            /*Format the input string */
+            strcpy(buffer_send, "FILE\n");
+            strcat(buffer_send, buffer);
 
             /* Send message to server. */
-            /*          write(socket_tcp, buffer_send, strlen(buffer_send));*/
+            if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
+                perror("Send to, failed.");
+                exit(EXIT_FAILURE);
+            }
 
             /*[> Read message from server. <]*/
             /*read(socket_tcp, buffer_received, MAX_LINE-1);*/
@@ -199,8 +208,11 @@ int main(int argc, char *argv[]) {
             /*printf("Server responded: Data is written to the file named: %s\n", file_name);*/
             /*[> close the file and free the memory <]*/
             /*fclose(fp);*/
-            /*free(file_name);*/
-            /*}*/
+
+            /*Free memory*/
+            free(file_name);
+            free(buffer);
+            free(buffer_send);
         }
         else if (strncmp(buffer, "q", 1) == 0) {
             fprintf(stderr, "Now should exit.\n");

commit bf3c3984f52403ee2f16314c186b307f7c8df339
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sun Feb 12 00:52:22 2017 -0500

    fix: memory allocation and management for char pointers

diff --git a/client/client.c b/client/client.c
index 4347731..32bb839 100644
--- a/client/client.c
+++ b/client/client.c
@@ -142,7 +142,7 @@ int main(int argc, char *argv[]) {
             fgets(buffer, MAX_LINE, stdin);
            
             /*CAP + 2 new lines + null terminator = 6*/
-            buffer_send =  (char *) malloc(sizeof(buffer_send) * (strlen(buffer) + 6)); 
+            buffer_send =  (char *) malloc(sizeof(buffer_send) * (strlen(buffer))); 
             printf("size of buffer: %d\n", strlen(buffer));
             /* Format the input string */
             strcpy(buffer_send, "CAP\n");
@@ -160,7 +160,8 @@ int main(int argc, char *argv[]) {
             buffer_received = (char *) malloc(sizeof(buffer_received) * MAX_LINE);
             recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
             if (recvlen > 0) {
-                /*buffer_received[recvlen] = '\0';*/
+                buffer_received[recvlen] = '\0';
+                printf("total bytest received: %d.\n", recvlen);
                 printf("Server responded: %s\n", buffer_received);
             }
 
diff --git a/server/server.c b/server/server.c
index 562f889..ef81fe7 100644
--- a/server/server.c
+++ b/server/server.c
@@ -133,7 +133,7 @@ int main(int argc, char *argv[]) {
             buffer[recvlen] = '\0';
             printf("received message: \"%s\"\n", buffer);
         }
-
+        printf("buffer len: %d\n.", strlen(buffer));
         /*  Wait for a connection, then accept() it  */
 
         /*         if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {*/
@@ -236,8 +236,6 @@ int main(int argc, char *argv[]) {
         /*}*/
 
         /*   [>* free the memory */
-        memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-        memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
 
         /*  Close the connected socket  */
         /*         if ( close(socket_tcp) < 0 ) {*/

commit b3ba6df31f1b519559f76a8a9787e7fee9505f43
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 23:51:37 2017 -0500

    fix: use char pointers for strings in server

diff --git a/client/client.c b/client/client.c
index 3161559..4347731 100644
--- a/client/client.c
+++ b/client/client.c
@@ -129,25 +129,24 @@ int main(int argc, char *argv[]) {
 
     /*  Get string to follow user commands */
     do {
-        buffer = (char *) malloc(sizeof(char *) * MAX_LINE);
+        buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
         printf("Insert your command: ");
         fgets(buffer, MAX_LINE, stdin);
 
         if (strncmp(buffer, "s", 1) == 0) {
             /*Reset buffer to get the string.*/
             free(buffer);
-            buffer =  malloc(sizeof(char *) * MAX_LINE);
+            buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
             
             printf("\nPlease Enter a string: ");
             fgets(buffer, MAX_LINE, stdin);
            
             /*CAP + 2 new lines + null terminator = 6*/
-            buffer_send =  malloc(sizeof(char *) * (strlen(buffer) + 6)); 
-            
+            buffer_send =  (char *) malloc(sizeof(buffer_send) * (strlen(buffer) + 6)); 
+            printf("size of buffer: %d\n", strlen(buffer));
             /* Format the input string */
             strcpy(buffer_send, "CAP\n");
             strcat(buffer_send, buffer);
-            strcat(buffer_send, "\n");
             
             printf("to send length: %d\n", strlen(buffer_send));
             /*Send message to server via UDP*/
@@ -158,29 +157,30 @@ int main(int argc, char *argv[]) {
 
             /*Read message back from server via UDP*/
             int recvlen = 0;
+            buffer_received = (char *) malloc(sizeof(buffer_received) * MAX_LINE);
             recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
             if (recvlen > 0) {
-                buffer_received[recvlen] = '\0';
+                /*buffer_received[recvlen] = '\0';*/
                 printf("Server responded: %s\n", buffer_received);
             }
 
 
             /* reset buffer to get only relevant string */
             free(buffer);
-            buffer_received[0] = '/0';
+            free(buffer_received);
             free(buffer_send); 
             /*printf("Server responded: %s", buffer);*/
         }
         else if (strncmp(buffer, "t", 1) == 0) {
-            printf("\nPlease Enter a string: ");
-            fgets(buffer, MAX_LINE, stdin);
+        /*    printf("\nPlease Enter a string: ");*/
+            /*fgets(buffer, MAX_LINE, stdin);*/
 
-            file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
-            memcpy(file_name, buffer, strlen(buffer) - 1);  
+            /*file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));*/
+            /*memcpy(file_name, buffer, strlen(buffer) - 1);  */
 
             /* Format the input string */
-            strcpy(buffer_send, "FILE\n");
-            strcat(buffer_send, buffer);
+          /*  strcpy(buffer_send, "FILE\n");*/
+            /*strcat(buffer_send, buffer);*/
 
             /* Send message to server. */
             /*          write(socket_tcp, buffer_send, strlen(buffer_send));*/
@@ -212,12 +212,6 @@ int main(int argc, char *argv[]) {
         }
         else 
             printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
-
-        /* free the memory */
-        memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-        memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
-        memset(buffer_received, 0, (sizeof buffer_received[0]) * MAX_LINE);
-
     } while (strncmp(buffer, "q", 1) != 0);
 
     return EXIT_SUCCESS;
diff --git a/server/server.c b/server/server.c
index 239d961..562f889 100644
--- a/server/server.c
+++ b/server/server.c
@@ -42,10 +42,10 @@ int main(int argc, char *argv[]) {
     struct    sockaddr_in servaddr;  /*  socket address structure  */
     struct sockaddr_in remaddr;  /* remote address */
     socklen_t addrlen = sizeof(remaddr); /* length of remote address */
-    char      buffer[MAX_LINE];      /*  character buffer          */
-    char      buffer_send[MAX_LINE];
+    char     *buffer;      /*  character buffer          */
+    char     *buffer_send;
     char     *endptr;                /*  for strtol()              */
-    char     to_capitalize[MAX_LINE];         /*  store user string to capitalize */
+    char     *to_capitalize;         /*  store user string to capitalize */
     char     *file_name;             /*  for storing file_name to be searched in the server */
     FILE     *fp;                    /*  file pointer */
 
@@ -126,6 +126,7 @@ int main(int argc, char *argv[]) {
         /*UDP connection*/
         printf("Waiting on port %d\n", port);
         int recvlen = 0;
+        buffer = (char *) malloc(sizeof(buffer) * MAX_LINE);
         recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
         printf("recieved %d bytes\n", recvlen);
         if (recvlen > 0) {
@@ -144,7 +145,7 @@ int main(int argc, char *argv[]) {
         if (strncmp(buffer, "CAP", 3) == 0) {
             /*number of relevant bytes of message */
             /*= buffer length - 'CAP' length - length of two line breaks - end of string */
-
+            to_capitalize = (char *) malloc(sizeof(to_capitalize) * strlen(buffer));
             strncpy(to_capitalize, buffer + 4, recvlen - 4);
             printf("what to upper?: %s", to_capitalize);
             /*[> Capitalize the messsage <]*/
@@ -165,15 +166,14 @@ int main(int argc, char *argv[]) {
             printf("to send length: %d\n", strlen(to_capitalize));
             /*[> send the formatted message to the client <]*/
             /*Add null char at the end*/
-            to_capitalize[strlen(to_capitalize)] = '\0';
             int sentlen = 0;
             sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize), 0, (struct sockaddr *) &remaddr, addrlen);
             if (sentlen < 0) {
                 perror("Sending failed.");
             }
             /*[> free the memory <]*/
-            to_capitalize[0] = '\0';
-            buffer[0] = '\0';
+            free(to_capitalize);
+            free(buffer);
         }
 
         /*if (strncmp(buffer, "FILE", 4) == 0) {*/

commit c75c910a2374d504343b14fbaa6d3e708d95054c
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 23:10:28 2017 -0500

    fix: use dynamic allocation of char array.

diff --git a/client/client.c b/client/client.c
index c874dce..3161559 100644
--- a/client/client.c
+++ b/client/client.c
@@ -46,9 +46,9 @@ int main(int argc, char *argv[]) {
     struct    sockaddr_in servaddr;       /*  socket address structure           */
     struct    sockaddr_in remaddr;        /*  remote address               	     */
     socklen_t addrlen = sizeof(remaddr);  /*  length of remote address 	     */
-    char      buffer[MAX_LINE];           /*  character buffer                   */
-    char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
-    char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
+    char     *buffer;           /*  character buffer                   */
+    char     *buffer_send;      /*  Holds message to be send to server */
+    char     *buffer_received;  /*  Holds message send by server       */
     char     *szAddress;                  /*  Holds remote IP address            */
     char     *udpPort;			 /* Holds server upd port */
     char     *tcpPort;                     /*  Holds server tcp port                  */
@@ -129,22 +129,27 @@ int main(int argc, char *argv[]) {
 
     /*  Get string to follow user commands */
     do {
+        buffer = (char *) malloc(sizeof(char *) * MAX_LINE);
         printf("Insert your command: ");
         fgets(buffer, MAX_LINE, stdin);
 
         if (strncmp(buffer, "s", 1) == 0) {
             /*Reset buffer to get the string.*/
-            buffer[0] = 0;
+            free(buffer);
+            buffer =  malloc(sizeof(char *) * MAX_LINE);
+            
             printf("\nPlease Enter a string: ");
             fgets(buffer, MAX_LINE, stdin);
-
+           
+            /*CAP + 2 new lines + null terminator = 6*/
+            buffer_send =  malloc(sizeof(char *) * (strlen(buffer) + 6)); 
+            
             /* Format the input string */
             strcpy(buffer_send, "CAP\n");
             strcat(buffer_send, buffer);
             strcat(buffer_send, "\n");
             
             printf("to send length: %d\n", strlen(buffer_send));
-            buffer_send[strlen(buffer_send)] = 0; /*Experiment*/
             /*Send message to server via UDP*/
             if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
                 perror("Send to, failed.");
@@ -155,15 +160,15 @@ int main(int argc, char *argv[]) {
             int recvlen = 0;
             recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
             if (recvlen > 0) {
-                buffer_received[recvlen] = 0;
+                buffer_received[recvlen] = '\0';
                 printf("Server responded: %s\n", buffer_received);
             }
 
 
             /* reset buffer to get only relevant string */
-            buffer[0] = 0;
-            buffer_received[0] = 0;
-            buffer_send[0] = 0;
+            free(buffer);
+            buffer_received[0] = '/0';
+            free(buffer_send); 
             /*printf("Server responded: %s", buffer);*/
         }
         else if (strncmp(buffer, "t", 1) == 0) {
diff --git a/server/server.c b/server/server.c
index 774b5e6..239d961 100644
--- a/server/server.c
+++ b/server/server.c
@@ -129,7 +129,7 @@ int main(int argc, char *argv[]) {
         recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
         printf("recieved %d bytes\n", recvlen);
         if (recvlen > 0) {
-            buffer[recvlen] = 0;
+            buffer[recvlen] = '\0';
             printf("received message: \"%s\"\n", buffer);
         }
 
@@ -149,7 +149,7 @@ int main(int argc, char *argv[]) {
             printf("what to upper?: %s", to_capitalize);
             /*[> Capitalize the messsage <]*/
             int index = 0;
-            while (to_capitalize[index] != 0) {
+            while (to_capitalize[index] != '\0') {
                 if (islower(to_capitalize[index])) {
                     to_capitalize[index] = toupper(to_capitalize[index]);
                 }
@@ -165,15 +165,15 @@ int main(int argc, char *argv[]) {
             printf("to send length: %d\n", strlen(to_capitalize));
             /*[> send the formatted message to the client <]*/
             /*Add null char at the end*/
-            to_capitalize[strlen(to_capitalize)] = 0;
+            to_capitalize[strlen(to_capitalize)] = '\0';
             int sentlen = 0;
             sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize), 0, (struct sockaddr *) &remaddr, addrlen);
             if (sentlen < 0) {
                 perror("Sending failed.");
             }
             /*[> free the memory <]*/
-            to_capitalize[0] = 0;
-            buffer[0] = 0;
+            to_capitalize[0] = '\0';
+            buffer[0] = '\0';
         }
 
         /*if (strncmp(buffer, "FILE", 4) == 0) {*/

commit 71c5a032fe50d36f9a1b3c3892659e4916bcfdd0
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 22:16:27 2017 -0500

    fix: insert zero to indicate the termination of string.

diff --git a/client/client.c b/client/client.c
index b381708..c874dce 100644
--- a/client/client.c
+++ b/client/client.c
@@ -144,6 +144,7 @@ int main(int argc, char *argv[]) {
             strcat(buffer_send, "\n");
             
             printf("to send length: %d\n", strlen(buffer_send));
+            buffer_send[strlen(buffer_send)] = 0; /*Experiment*/
             /*Send message to server via UDP*/
             if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
                 perror("Send to, failed.");
diff --git a/server/server.c b/server/server.c
index 2d5aea7..774b5e6 100644
--- a/server/server.c
+++ b/server/server.c
@@ -145,7 +145,7 @@ int main(int argc, char *argv[]) {
             /*number of relevant bytes of message */
             /*= buffer length - 'CAP' length - length of two line breaks - end of string */
 
-            memmove(to_capitalize, buffer + 4, strlen(buffer) - 4);
+            strncpy(to_capitalize, buffer + 4, recvlen - 4);
             printf("what to upper?: %s", to_capitalize);
             /*[> Capitalize the messsage <]*/
             int index = 0;
@@ -162,13 +162,13 @@ int main(int argc, char *argv[]) {
 
             /*[> parse the capitalized message to send to the client <]*/
             printf("to send: %s\n", to_capitalize);
-            printf("to send length: %d\n", strlen(to_capitalize);
+            printf("to send length: %d\n", strlen(to_capitalize));
             /*[> send the formatted message to the client <]*/
-
+            /*Add null char at the end*/
+            to_capitalize[strlen(to_capitalize)] = 0;
             int sentlen = 0;
             sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize), 0, (struct sockaddr *) &remaddr, addrlen);
             if (sentlen < 0) {
-                buffer_send[sentlen] = 0;
                 perror("Sending failed.");
             }
             /*[> free the memory <]*/

commit f4345b6e2ca09c0de9fe404b59a0710139121ae7
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 21:57:32 2017 -0500

    fix: garbage value in server response

diff --git a/server/server.c b/server/server.c
index 157d401..2d5aea7 100644
--- a/server/server.c
+++ b/server/server.c
@@ -149,7 +149,7 @@ int main(int argc, char *argv[]) {
             printf("what to upper?: %s", to_capitalize);
             /*[> Capitalize the messsage <]*/
             int index = 0;
-            while (to_capitalize[index] < strlen(buffer) - 4) {
+            while (to_capitalize[index] != 0) {
                 if (islower(to_capitalize[index])) {
                     to_capitalize[index] = toupper(to_capitalize[index]);
                 }
@@ -162,7 +162,7 @@ int main(int argc, char *argv[]) {
 
             /*[> parse the capitalized message to send to the client <]*/
             printf("to send: %s\n", to_capitalize);
-            printf("to send length: %d\n", strlen(to_capitalize));
+            printf("to send length: %d\n", strlen(to_capitalize);
             /*[> send the formatted message to the client <]*/
 
             int sentlen = 0;

commit 3460c3bf02763c25a2815140342ffcf98e7e7982
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 21:51:50 2017 -0500

    fix: garbage value in server reponse buffer.

diff --git a/client/client.c b/client/client.c
index 15e07db..b381708 100644
--- a/client/client.c
+++ b/client/client.c
@@ -39,195 +39,197 @@ int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char
 
 int main(int argc, char *argv[]) {
 
-	int       socket_tcp;                    /*  connection socket                  */
-	int	      socket_udp;
-	short int tcp_port;                   /*  tcp port number                        */
-	short int udp_port;                   /*  udp port number                    */
-	struct    sockaddr_in servaddr;       /*  socket address structure           */
-	struct    sockaddr_in remaddr;        /*  remote address               	     */
-	socklen_t addrlen = sizeof(remaddr);  /*  length of remote address 	     */
-	char      buffer[MAX_LINE];           /*  character buffer                   */
-	char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
-	char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
-	char     *szAddress;                  /*  Holds remote IP address            */
-	char     *udpPort;			 /* Holds server upd port */
-	char     *tcpPort;                     /*  Holds server tcp port                  */
-	char     *endptr;                     /*  for strtol()                       */
-	FILE     *fp;                         /*  file pointer                       */
-	char     *file_name;                  /*  for creating and writing data into */
-
-
-	/*  Get command line arguments  */
-
-	ParseCmdLine(argc, argv, &szAddress, &tcpPort, &udpPort);
-
-
-	/* TCP connection */
-
-	/*  Set the remote port  */
-
-	/*tcp_port = strtol(tcpPort, &endptr, 0);*/
-	/*if ( *endptr ) {*/
-	/*printf("ECHOCLNT: Invalid port supplied.\n");*/
-	/*exit(EXIT_FAILURE);*/
-	/*}*/
-
-
-	/*[>  Create the listening socket  <]*/
-
-	/*if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
-	/*fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");*/
-	/*exit(EXIT_FAILURE);*/
-	/*}*/
-
-	/*  Set all bytes in socket address structure to*/
-	/*zero, and fill in the relevant data members   */
-
-		/*memset(&servaddr, 0, sizeof(servaddr));*/
-		/*servaddr.sin_family      = AF_INET;*/
-		/*servaddr.sin_port        = htons(tcp_port);*/
-
-		/*[>  Set the remote IP address  <]*/
-
-		/*if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {*/
-		/*printf("ECHOCLNT: Invalid remote IP address.\n");*/
-		/*exit(EXIT_FAILURE);*/
-		/*}*/
-
-
-		/*[>  connect() to the remote echo server  <]*/
-
-		/*if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {*/
-		/*perror("Connection failed");*/
-		/*exit(EXIT_FAILURE);*/
-		/*}*/
-
-		/* UDP connection */
-
-		/*  Set the remote port  */
-		memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for udp_port */
-	udp_port = strtol(udpPort, &endptr, 0);
-	if ( *endptr ) {
-		printf("ECHOCLNT: Invalid port supplied.\n");
-		exit(EXIT_FAILURE);
-	}
-
-	/*Create UDP socket*/
-
-	if ( (socket_udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
-		fprintf(stderr, "ECHOCLNT: Error creating UDP socket.\n");
-		exit(EXIT_FAILURE);
-	}
-
-	/*  Set all bytes in socket address structure to
-	    zero, and fill in the relevant data members   */
-
-	memset(&servaddr, 0, sizeof(servaddr));
-	servaddr.sin_family      = AF_INET;
-	servaddr.sin_port        = htons(udp_port);
-	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-
-	/*  Get string to follow user commands */
-	do {
-		printf("Insert your command: ");
-		fgets(buffer, MAX_LINE, stdin);
-
-		if (strncmp(buffer, "s", 1) == 0) {
-			printf("\nPlease Enter a string: ");
-			fgets(buffer, MAX_LINE, stdin);
-
-			/* Format the input string */
-			strcpy(buffer_send, "CAP\n");
-			strcat(buffer_send, buffer);
-			strcat(buffer_send, "\n");
-
-			/*Send message to server via UDP*/
-			if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
-				perror("Send to, failed.");
-				exit(EXIT_FAILURE);
-			}
-
-			/*Read message back from server via UDP*/
-			int recvlen = 0;
-			recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
-			if (recvlen > 0) {
-				buffer_received[recvlen] = 0;
-				printf("Server responded: \"%s\n", buffer);
-			}
-
-			/*read(socket_tcp, buffer_received, MAX_LINE-1);*/
-
-			/* reset buffer to get only relevant string */
-			/*            memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);*/
-
-			/*memcpy(buffer, buffer_received + 2, strlen(buffer_received) - 2);*/
-			/*printf("Server responded: %s", buffer);*/
-		}
-		else if (strncmp(buffer, "t", 1) == 0) {
-			printf("\nPlease Enter a string: ");
-			fgets(buffer, MAX_LINE, stdin);
-
-			file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
-			memcpy(file_name, buffer, strlen(buffer) - 1);  
-
-			/* Format the input string */
-			strcpy(buffer_send, "FILE\n");
-			strcat(buffer_send, buffer);
-
-			/* Send message to server. */
-			/*          write(socket_tcp, buffer_send, strlen(buffer_send));*/
-
-			/*[> Read message from server. <]*/
-			/*read(socket_tcp, buffer_received, MAX_LINE-1);*/
-
-			/*[> write the data to the file. <]*/
-			/*if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {*/
-			/*printf("Server responded: %s\n", buffer_received + 2);*/
-			/*}*/
-			/*else {*/
-			/*fp = fopen(file_name, "wb");*/
-			/*fwrite(buffer_received, 1, strlen(buffer_received), fp);*/
-			/*printf("Server responded: Data is written to the file named: %s\n", file_name);*/
-			/*[> close the file and free the memory <]*/
-			/*fclose(fp);*/
-			/*free(file_name);*/
-			/*}*/
-		}
-		else if (strncmp(buffer, "q", 1) == 0) {
-			fprintf(stderr, "Now should exit.\n");
-			if (close(socket_tcp) < 0 ) {
-				fprintf(stderr, "ECHOSERV: Error calling close()\n");
-				exit(EXIT_FAILURE);
-			}
-
-			return EXIT_SUCCESS;
-		}
-		else 
-			printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
-
-		/* free the memory */
-		memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-		memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
-		memset(buffer_received, 0, (sizeof buffer_received[0]) * MAX_LINE);
-
-	} while (strncmp(buffer, "q", 1) != 0);
-
-	return EXIT_SUCCESS;
+    int       socket_tcp;                    /*  connection socket                  */
+    int	      socket_udp;
+    short int tcp_port;                   /*  tcp port number                        */
+    short int udp_port;                   /*  udp port number                    */
+    struct    sockaddr_in servaddr;       /*  socket address structure           */
+    struct    sockaddr_in remaddr;        /*  remote address               	     */
+    socklen_t addrlen = sizeof(remaddr);  /*  length of remote address 	     */
+    char      buffer[MAX_LINE];           /*  character buffer                   */
+    char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
+    char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
+    char     *szAddress;                  /*  Holds remote IP address            */
+    char     *udpPort;			 /* Holds server upd port */
+    char     *tcpPort;                     /*  Holds server tcp port                  */
+    char     *endptr;                     /*  for strtol()                       */
+    FILE     *fp;                         /*  file pointer                       */
+    char     *file_name;                  /*  for creating and writing data into */
+
+
+    /*  Get command line arguments  */
+
+    ParseCmdLine(argc, argv, &szAddress, &tcpPort, &udpPort);
+
+
+    /* TCP connection */
+
+    /*  Set the remote port  */
+
+    /*tcp_port = strtol(tcpPort, &endptr, 0);*/
+    /*if ( *endptr ) {*/
+    /*printf("ECHOCLNT: Invalid port supplied.\n");*/
+    /*exit(EXIT_FAILURE);*/
+    /*}*/
+
+
+    /*[>  Create the listening socket  <]*/
+
+    /*if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
+    /*fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");*/
+    /*exit(EXIT_FAILURE);*/
+    /*}*/
+
+    /*  Set all bytes in socket address structure to*/
+    /*zero, and fill in the relevant data members   */
+
+    /*memset(&servaddr, 0, sizeof(servaddr));*/
+    /*servaddr.sin_family      = AF_INET;*/
+    /*servaddr.sin_port        = htons(tcp_port);*/
+
+    /*[>  Set the remote IP address  <]*/
+
+    /*if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {*/
+    /*printf("ECHOCLNT: Invalid remote IP address.\n");*/
+    /*exit(EXIT_FAILURE);*/
+    /*}*/
+
+
+    /*[>  connect() to the remote echo server  <]*/
+
+    /*if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {*/
+    /*perror("Connection failed");*/
+    /*exit(EXIT_FAILURE);*/
+    /*}*/
+
+    /* UDP connection */
+
+    /*  Set the remote port  */
+    memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for udp_port */
+    udp_port = strtol(udpPort, &endptr, 0);
+    if ( *endptr ) {
+        printf("ECHOCLNT: Invalid port supplied.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    /*Create UDP socket*/
+
+    if ( (socket_udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
+        fprintf(stderr, "ECHOCLNT: Error creating UDP socket.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    /*  Set all bytes in socket address structure to
+        zero, and fill in the relevant data members   */
+
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family      = AF_INET;
+    servaddr.sin_port        = htons(udp_port);
+    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+
+    /*  Get string to follow user commands */
+    do {
+        printf("Insert your command: ");
+        fgets(buffer, MAX_LINE, stdin);
+
+        if (strncmp(buffer, "s", 1) == 0) {
+            /*Reset buffer to get the string.*/
+            buffer[0] = 0;
+            printf("\nPlease Enter a string: ");
+            fgets(buffer, MAX_LINE, stdin);
+
+            /* Format the input string */
+            strcpy(buffer_send, "CAP\n");
+            strcat(buffer_send, buffer);
+            strcat(buffer_send, "\n");
+            
+            printf("to send length: %d\n", strlen(buffer_send));
+            /*Send message to server via UDP*/
+            if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
+                perror("Send to, failed.");
+                exit(EXIT_FAILURE);
+            }
+
+            /*Read message back from server via UDP*/
+            int recvlen = 0;
+            recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
+            if (recvlen > 0) {
+                buffer_received[recvlen] = 0;
+                printf("Server responded: %s\n", buffer_received);
+            }
+
+
+            /* reset buffer to get only relevant string */
+            buffer[0] = 0;
+            buffer_received[0] = 0;
+            buffer_send[0] = 0;
+            /*printf("Server responded: %s", buffer);*/
+        }
+        else if (strncmp(buffer, "t", 1) == 0) {
+            printf("\nPlease Enter a string: ");
+            fgets(buffer, MAX_LINE, stdin);
+
+            file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
+            memcpy(file_name, buffer, strlen(buffer) - 1);  
+
+            /* Format the input string */
+            strcpy(buffer_send, "FILE\n");
+            strcat(buffer_send, buffer);
+
+            /* Send message to server. */
+            /*          write(socket_tcp, buffer_send, strlen(buffer_send));*/
+
+            /*[> Read message from server. <]*/
+            /*read(socket_tcp, buffer_received, MAX_LINE-1);*/
+
+            /*[> write the data to the file. <]*/
+            /*if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {*/
+            /*printf("Server responded: %s\n", buffer_received + 2);*/
+            /*}*/
+            /*else {*/
+            /*fp = fopen(file_name, "wb");*/
+            /*fwrite(buffer_received, 1, strlen(buffer_received), fp);*/
+            /*printf("Server responded: Data is written to the file named: %s\n", file_name);*/
+            /*[> close the file and free the memory <]*/
+            /*fclose(fp);*/
+            /*free(file_name);*/
+            /*}*/
+        }
+        else if (strncmp(buffer, "q", 1) == 0) {
+            fprintf(stderr, "Now should exit.\n");
+            if (close(socket_tcp) < 0 ) {
+                fprintf(stderr, "ECHOSERV: Error calling close()\n");
+                exit(EXIT_FAILURE);
+            }
+
+            return EXIT_SUCCESS;
+        }
+        else 
+            printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
+
+        /* free the memory */
+        memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+        memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
+        memset(buffer_received, 0, (sizeof buffer_received[0]) * MAX_LINE);
+
+    } while (strncmp(buffer, "q", 1) != 0);
+
+    return EXIT_SUCCESS;
 }
 
 
 int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort) {
-	/* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
-	if (argc == 4) {
-		*tcpPort = argv[1];
-		*szAddress = argv[2];
-		*udpPort = argv[3];
-	}
-	else {
-		printf("Usage:\n\n");
-		printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
-		exit(EXIT_SUCCESS);
-	}
-	return 0;
+    /* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
+    if (argc == 4) {
+        *tcpPort = argv[1];
+        *szAddress = argv[2];
+        *udpPort = argv[3];
+    }
+    else {
+        printf("Usage:\n\n");
+        printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
+        exit(EXIT_SUCCESS);
+    }
+    return 0;
 }
 
diff --git a/server/server.c b/server/server.c
index 2a3a5e1..157d401 100644
--- a/server/server.c
+++ b/server/server.c
@@ -35,218 +35,217 @@ Simple TCP/IP echo server.
 
 
 int main(int argc, char *argv[]) {
-	int       socket_tcp;                    /*  connection socket                  */
-	int	      socket_udp;
-	int       list_s;                /*  listening socket          */
-	short int port;                  /*  port number: UDP               */
-	struct    sockaddr_in servaddr;  /*  socket address structure  */
-	struct sockaddr_in remaddr;  /* remote address */
-	socklen_t addrlen = sizeof(remaddr); /* length of remote address */
-	char      buffer[MAX_LINE];      /*  character buffer          */
-	char      buffer_send[MAX_LINE];
-	char     *endptr;                /*  for strtol()              */
-	char     to_capitalize[MAX_LINE];         /*  store user string to capitalize */
-	char     *file_name;             /*  for storing file_name to be searched in the server */
-	FILE     *fp;                    /*  file pointer */
+    int       socket_tcp;                    /*  connection socket                  */
+    int	      socket_udp;
+    int       list_s;                /*  listening socket          */
+    short int port;                  /*  port number: UDP               */
+    struct    sockaddr_in servaddr;  /*  socket address structure  */
+    struct sockaddr_in remaddr;  /* remote address */
+    socklen_t addrlen = sizeof(remaddr); /* length of remote address */
+    char      buffer[MAX_LINE];      /*  character buffer          */
+    char      buffer_send[MAX_LINE];
+    char     *endptr;                /*  for strtol()              */
+    char     to_capitalize[MAX_LINE];         /*  store user string to capitalize */
+    char     *file_name;             /*  for storing file_name to be searched in the server */
+    FILE     *fp;                    /*  file pointer */
 
 
-	/*  Get port number from the command line.*/
-
-	if ( argc == 2 ) {
-		port = strtol(argv[1], &endptr, 0);
-		if ( *endptr ) {
-			fprintf(stderr, "ECHOSERV: Invalid port number.\n");
-			exit(EXIT_FAILURE);
-		}
-	}
-	else {
-		fprintf(stderr, "ECHOSERV: Invalid arguments.\n");
-		printf("Usage:\n\n");
-		printf("    <server> <remote Port>\n\n");
-		exit(EXIT_FAILURE);
-	}
-
-	/* TCP connection */	
-	/*  Create the listening socket  */
-
-	/* if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
-	/*perror("ECHOSERV: Error creating listening socket.\n");*/
-
-	/*exit(EXIT_FAILURE);*/
-	/*}*/
-
-
-	/*  Set all bytes in socket address structure to*/
-	/*zero, and fill in the relevant data members   */
-
-	/*memset(&servaddr, 0, sizeof(servaddr));*/
-	/*servaddr.sin_family      = AF_INET;*/
-	/*servaddr.sin_addr.s_addr = htonl(INADDR_ANY);*/
-	/*servaddr.sin_port        = htons(port);*/
-
-
-	/*  Bind our socket addresss to the */
-	/*listening socket, and call listen()  */
-
-	/*if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {*/
-	/*fprintf(stderr, "ECHOSERV: Error calling bind()\n");*/
-	/*exit(EXIT_FAILURE);*/
-	/*}*/
-
-	/*if ( listen(list_s, LISTENQ) < 0 ) {*/
-	/*perror("ECHOSERV: Error calling listen()\n");*/
-	/*exit(EXIT_FAILURE);*/
-	/*}*/
-
-	/*UDP Connection  */
-
-	socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
-
-	/*  Set all bytes in socket address structure to
-	    zero, and fill in the relevant data members   */
-
-	memset(&servaddr, 0, sizeof(servaddr));
-	servaddr.sin_family      = AF_INET;
-	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-	servaddr.sin_port        = htons(port);
-
-
-	/*  Bind our socket addresss to the 
-	    listening socket, and call listen()  */
-
-	if ( bind(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
-		fprintf(stderr, "ECHOSERV: Error calling bind()\n");
-		exit(EXIT_FAILURE);
-	}
-
-
-	/*  Enter an infinite loop to respond to client requests.  */
-
-	while ( 1 ) {
-		/*UDP connection*/
-		printf("Waiting on port %d\n", port);
-		int recvlen = 0;
-		recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
-		printf("recieved %d bytes\n", recvlen);
-		if (recvlen > 0) {
-			buffer[recvlen] = 0;
-			printf("received message: \"%s\"\n", buffer);
-		}
-
-		/*  Wait for a connection, then accept() it  */
-
-		/*         if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {*/
-		/*fprintf(stderr, "ECHOSERV: Error calling accept()\n");*/
-		/*exit(EXIT_FAILURE);*/
-		/*}*/
-
-
-		if (strncmp(buffer, "CAP", 3) == 0) {
-			/*number of relevant bytes of message */
-			/*= buffer length - 'CAP' length - length of two line breaks - end of string */
-
-			memmove(to_capitalize, buffer + 4, strlen(buffer) - 4);
-			printf("what to upper?: %s", to_capitalize);
-			/*[> Capitalize the messsage <]*/
-			int index = 0;
-			while (to_capitalize[index] != '\0') {
-				if (islower(to_capitalize[index])) {
-					to_capitalize[index] = toupper(to_capitalize[index]);
-				}
-				else {
-					to_capitalize[index] = to_capitalize[index];
-				}
-				index++;
-			}
-
-
-			/*[> parse the capitalized message to send to the client <]*/
-
-			strcat(buffer_send, to_capitalize);
-
-			printf("to send: %s\n", to_capitalize);
-			/*[> send the formatted message to the client <]*/
-
-			int sentlen = 0;
-			sentlen = sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen);
-			if (sentlen < 0) {
-				buffer_send[sentlen] = 0;
-				perror("Sending failed.");
-			}
-			/*[> free the memory <]*/
-			to_capitalize[0] = 0;
-		}
-
-		/*if (strncmp(buffer, "FILE", 4) == 0) {*/
-		/*file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));*/
-		/*memcpy(file_name, buffer + 5, strlen(buffer) - 6);*/
-
-		/*[> Find file name and read that file <]*/
-		/*fp = fopen(file_name, "rb");*/
-		/*if (fp) {*/
-		/*long lSize;*/
-		/*void* large_buffer;*/
-		/*size_t result;*/
-
-		/*[> obtain file size <]*/
-		/*fseek(fp, 0, SEEK_END);*/
-		/*lSize = ftell(fp);*/
-		/*rewind(fp); [> Put the postion of pointer back to the start of the file <]*/
-
-		/*[> allocate memory to hold the whole file <]*/
-		/*large_buffer = (void* ) malloc(sizeof(void*) * lSize);*/
-		/*if (large_buffer == NULL) {*/
-		/*perror("Error in allocating required memory: ");*/
-		/*}*/
-
-		/*[> copy the file into the buffer <]*/
-		/*result = fread(large_buffer, 1, lSize, fp);*/
-		/*if (result != lSize) {*/
-		/*printf("Error reading whole file.\n");*/
-		/*}*/
-
-		/*[> close the file and later free the large_buffer <]*/
-		/*fclose(fp);*/
-
-		/*[> send the buffer to the client <]*/
-		/*if (MAX_LINE < lSize) {*/
-		/*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
-		/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-		/*}*/
-		/*else {*/
-		/*sprintf(buffer_send, "%d", lSize);*/
-		/*strcat(buffer_send, "\n");*/
-		/*strcat(buffer_send, large_buffer);*/
-		/*write(socket_tcp, buffer_send, lSize);*/
-		/*}*/
-
-		/*[> free the memory <]*/
-		/*free(large_buffer);*/
-		/*free(file_name);*/
-		/*} else {*/
-		/*[> No such file <]*/
-		/*strcpy(buffer, "NOT FOUND");*/
-		/*sprintf(buffer_send, "%d", strlen(buffer));*/
-		/*strcat(buffer_send, "\n");*/
-		/*strcat(buffer_send, buffer);*/
-
-		/*[> Inform client that file is not in the server. <]*/
-		/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-		/*}*/
-
-		/*}*/
-
-		/*   [>* free the memory */
-		memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-		memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
-
-		/*  Close the connected socket  */
-		/*         if ( close(socket_tcp) < 0 ) {*/
-		/*perror("ECHOSERV: Error calling close()\n");*/
-		/*exit(EXIT_FAILURE);*/
-		/*}*/
-		/*else {*/
-		/*fprintf(stderr, "Connection closed.\n");*/
-		/*}*/
-	}
+    /*  Get port number from the command line.*/
+
+    if ( argc == 2 ) {
+        port = strtol(argv[1], &endptr, 0);
+        if ( *endptr ) {
+            fprintf(stderr, "ECHOSERV: Invalid port number.\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+    else {
+        fprintf(stderr, "ECHOSERV: Invalid arguments.\n");
+        printf("Usage:\n\n");
+        printf("    <server> <remote Port>\n\n");
+        exit(EXIT_FAILURE);
+    }
+
+    /* TCP connection */	
+    /*  Create the listening socket  */
+
+    /* if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
+    /*perror("ECHOSERV: Error creating listening socket.\n");*/
+
+    /*exit(EXIT_FAILURE);*/
+    /*}*/
+
+
+    /*  Set all bytes in socket address structure to*/
+    /*zero, and fill in the relevant data members   */
+
+    /*memset(&servaddr, 0, sizeof(servaddr));*/
+    /*servaddr.sin_family      = AF_INET;*/
+    /*servaddr.sin_addr.s_addr = htonl(INADDR_ANY);*/
+    /*servaddr.sin_port        = htons(port);*/
+
+
+    /*  Bind our socket addresss to the */
+    /*listening socket, and call listen()  */
+
+    /*if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {*/
+    /*fprintf(stderr, "ECHOSERV: Error calling bind()\n");*/
+    /*exit(EXIT_FAILURE);*/
+    /*}*/
+
+    /*if ( listen(list_s, LISTENQ) < 0 ) {*/
+    /*perror("ECHOSERV: Error calling listen()\n");*/
+    /*exit(EXIT_FAILURE);*/
+    /*}*/
+
+    /*UDP Connection  */
+
+    socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
+
+    /*  Set all bytes in socket address structure to
+        zero, and fill in the relevant data members   */
+
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family      = AF_INET;
+    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    servaddr.sin_port        = htons(port);
+
+
+    /*  Bind our socket addresss to the 
+        listening socket, and call listen()  */
+
+    if ( bind(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
+        fprintf(stderr, "ECHOSERV: Error calling bind()\n");
+        exit(EXIT_FAILURE);
+    }
+
+
+    /*  Enter an infinite loop to respond to client requests.  */
+
+    while ( 1 ) {
+        /*UDP connection*/
+        printf("Waiting on port %d\n", port);
+        int recvlen = 0;
+        recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
+        printf("recieved %d bytes\n", recvlen);
+        if (recvlen > 0) {
+            buffer[recvlen] = 0;
+            printf("received message: \"%s\"\n", buffer);
+        }
+
+        /*  Wait for a connection, then accept() it  */
+
+        /*         if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {*/
+        /*fprintf(stderr, "ECHOSERV: Error calling accept()\n");*/
+        /*exit(EXIT_FAILURE);*/
+        /*}*/
+
+
+        if (strncmp(buffer, "CAP", 3) == 0) {
+            /*number of relevant bytes of message */
+            /*= buffer length - 'CAP' length - length of two line breaks - end of string */
+
+            memmove(to_capitalize, buffer + 4, strlen(buffer) - 4);
+            printf("what to upper?: %s", to_capitalize);
+            /*[> Capitalize the messsage <]*/
+            int index = 0;
+            while (to_capitalize[index] < strlen(buffer) - 4) {
+                if (islower(to_capitalize[index])) {
+                    to_capitalize[index] = toupper(to_capitalize[index]);
+                }
+                else {
+                    to_capitalize[index] = to_capitalize[index];
+                }
+                index++;
+            }
+
+
+            /*[> parse the capitalized message to send to the client <]*/
+            printf("to send: %s\n", to_capitalize);
+            printf("to send length: %d\n", strlen(to_capitalize));
+            /*[> send the formatted message to the client <]*/
+
+            int sentlen = 0;
+            sentlen = sendto(socket_udp, to_capitalize, strlen(to_capitalize), 0, (struct sockaddr *) &remaddr, addrlen);
+            if (sentlen < 0) {
+                buffer_send[sentlen] = 0;
+                perror("Sending failed.");
+            }
+            /*[> free the memory <]*/
+            to_capitalize[0] = 0;
+            buffer[0] = 0;
+        }
+
+        /*if (strncmp(buffer, "FILE", 4) == 0) {*/
+        /*file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));*/
+        /*memcpy(file_name, buffer + 5, strlen(buffer) - 6);*/
+
+        /*[> Find file name and read that file <]*/
+        /*fp = fopen(file_name, "rb");*/
+        /*if (fp) {*/
+        /*long lSize;*/
+        /*void* large_buffer;*/
+        /*size_t result;*/
+
+        /*[> obtain file size <]*/
+        /*fseek(fp, 0, SEEK_END);*/
+        /*lSize = ftell(fp);*/
+        /*rewind(fp); [> Put the postion of pointer back to the start of the file <]*/
+
+        /*[> allocate memory to hold the whole file <]*/
+        /*large_buffer = (void* ) malloc(sizeof(void*) * lSize);*/
+        /*if (large_buffer == NULL) {*/
+        /*perror("Error in allocating required memory: ");*/
+        /*}*/
+
+        /*[> copy the file into the buffer <]*/
+        /*result = fread(large_buffer, 1, lSize, fp);*/
+        /*if (result != lSize) {*/
+        /*printf("Error reading whole file.\n");*/
+        /*}*/
+
+        /*[> close the file and later free the large_buffer <]*/
+        /*fclose(fp);*/
+
+        /*[> send the buffer to the client <]*/
+        /*if (MAX_LINE < lSize) {*/
+        /*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
+        /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+        /*}*/
+        /*else {*/
+        /*sprintf(buffer_send, "%d", lSize);*/
+        /*strcat(buffer_send, "\n");*/
+        /*strcat(buffer_send, large_buffer);*/
+        /*write(socket_tcp, buffer_send, lSize);*/
+        /*}*/
+
+        /*[> free the memory <]*/
+        /*free(large_buffer);*/
+        /*free(file_name);*/
+        /*} else {*/
+        /*[> No such file <]*/
+        /*strcpy(buffer, "NOT FOUND");*/
+        /*sprintf(buffer_send, "%d", strlen(buffer));*/
+        /*strcat(buffer_send, "\n");*/
+        /*strcat(buffer_send, buffer);*/
+
+        /*[> Inform client that file is not in the server. <]*/
+        /*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+        /*}*/
+
+        /*}*/
+
+        /*   [>* free the memory */
+        memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+        memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
+
+        /*  Close the connected socket  */
+        /*         if ( close(socket_tcp) < 0 ) {*/
+        /*perror("ECHOSERV: Error calling close()\n");*/
+        /*exit(EXIT_FAILURE);*/
+        /*}*/
+        /*else {*/
+        /*fprintf(stderr, "Connection closed.\n");*/
+        /*}*/
+    }
 }

commit 533bebcb69d3a6fea9767321681cf2dd9cbe609f
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 20:28:56 2017 -0500

    fix: buffer to hold only string to be capitalized.

diff --git a/server/server.c b/server/server.c
index 24a5eaa..2a3a5e1 100644
--- a/server/server.c
+++ b/server/server.c
@@ -145,8 +145,8 @@ int main(int argc, char *argv[]) {
 			/*number of relevant bytes of message */
 			/*= buffer length - 'CAP' length - length of two line breaks - end of string */
 
-			memcpy(to_capitalize, buffer + 4, strlen(buffer));
-
+			memmove(to_capitalize, buffer + 4, strlen(buffer) - 4);
+			printf("what to upper?: %s", to_capitalize);
 			/*[> Capitalize the messsage <]*/
 			int index = 0;
 			while (to_capitalize[index] != '\0') {
@@ -159,12 +159,12 @@ int main(int argc, char *argv[]) {
 				index++;
 			}
 
+
 			/*[> parse the capitalized message to send to the client <]*/
 
 			strcat(buffer_send, to_capitalize);
-			strcat(buffer_send, "\n");
-			
-			printf("to send: %s\n", buffer_send);
+
+			printf("to send: %s\n", to_capitalize);
 			/*[> send the formatted message to the client <]*/
 
 			int sentlen = 0;

commit f2045ad72ba30b5c4c46ef2ee2b417a38a030f69
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 19:45:51 2017 -0500

    fix: buffer to store capitalized string.

diff --git a/server/server.c b/server/server.c
index 46dfef4..24a5eaa 100644
--- a/server/server.c
+++ b/server/server.c
@@ -45,7 +45,7 @@ int main(int argc, char *argv[]) {
 	char      buffer[MAX_LINE];      /*  character buffer          */
 	char      buffer_send[MAX_LINE];
 	char     *endptr;                /*  for strtol()              */
-	char     *to_capitalize;         /*  store user string to capitalize */
+	char     to_capitalize[MAX_LINE];         /*  store user string to capitalize */
 	char     *file_name;             /*  for storing file_name to be searched in the server */
 	FILE     *fp;                    /*  file pointer */
 
@@ -145,8 +145,7 @@ int main(int argc, char *argv[]) {
 			/*number of relevant bytes of message */
 			/*= buffer length - 'CAP' length - length of two line breaks - end of string */
 
-			to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));
-			memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);
+			memcpy(to_capitalize, buffer + 4, strlen(buffer));
 
 			/*[> Capitalize the messsage <]*/
 			int index = 0;
@@ -175,8 +174,7 @@ int main(int argc, char *argv[]) {
 				perror("Sending failed.");
 			}
 			/*[> free the memory <]*/
-			free(to_capitalize);
-
+			to_capitalize[0] = 0;
 		}
 
 		/*if (strncmp(buffer, "FILE", 4) == 0) {*/

commit 46537ff94b3be803137073b22611f1648d1961d6
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 19:30:35 2017 -0500

    Parse message (of captalized string) to be sent by server.

diff --git a/client/client.c b/client/client.c
index 41cc9b5..15e07db 100644
--- a/client/client.c
+++ b/client/client.c
@@ -44,7 +44,7 @@ int main(int argc, char *argv[]) {
 	short int tcp_port;                   /*  tcp port number                        */
 	short int udp_port;                   /*  udp port number                    */
 	struct    sockaddr_in servaddr;       /*  socket address structure           */
-	struct    sockaddr_in_remaddr;        /*  remote address               	     */
+	struct    sockaddr_in remaddr;        /*  remote address               	     */
 	socklen_t addrlen = sizeof(remaddr);  /*  length of remote address 	     */
 	char      buffer[MAX_LINE];           /*  character buffer                   */
 	char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
@@ -151,8 +151,8 @@ int main(int argc, char *argv[]) {
 			int recvlen = 0;
 			recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
 			if (recvlen > 0) {
-				buffer[recvlen] = 0;
-				printf("received message: \"%s\n", buffer);
+				buffer_received[recvlen] = 0;
+				printf("Server responded: \"%s\n", buffer);
 			}
 
 			/*read(socket_tcp, buffer_received, MAX_LINE-1);*/
diff --git a/server/server.c b/server/server.c
index ed7d16a..46dfef4 100644
--- a/server/server.c
+++ b/server/server.c
@@ -162,11 +162,10 @@ int main(int argc, char *argv[]) {
 
 			/*[> parse the capitalized message to send to the client <]*/
 
-			sprintf(buffer_send, "%d", strlen(to_capitalize));
-			strcat(buffer_send, "\n");
 			strcat(buffer_send, to_capitalize);
-
-			printf("to send: %s\n", to_capitalize);
+			strcat(buffer_send, "\n");
+			
+			printf("to send: %s\n", buffer_send);
 			/*[> send the formatted message to the client <]*/
 
 			int sentlen = 0;

commit 7c4930aa7680d0db8979ddfbdb6a3376c388c0da
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 19:20:44 2017 -0500

    Implement receive capitalized string from server

diff --git a/client/client.c b/client/client.c
index 7b3dbb7..41cc9b5 100644
--- a/client/client.c
+++ b/client/client.c
@@ -44,6 +44,8 @@ int main(int argc, char *argv[]) {
 	short int tcp_port;                   /*  tcp port number                        */
 	short int udp_port;                   /*  udp port number                    */
 	struct    sockaddr_in servaddr;       /*  socket address structure           */
+	struct    sockaddr_in_remaddr;        /*  remote address               	     */
+	socklen_t addrlen = sizeof(remaddr);  /*  length of remote address 	     */
 	char      buffer[MAX_LINE];           /*  character buffer                   */
 	char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
 	char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
@@ -145,6 +147,14 @@ int main(int argc, char *argv[]) {
 				exit(EXIT_FAILURE);
 			}
 
+			/*Read message back from server via UDP*/
+			int recvlen = 0;
+			recvlen = recvfrom(socket_udp, buffer_received, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
+			if (recvlen > 0) {
+				buffer[recvlen] = 0;
+				printf("received message: \"%s\n", buffer);
+			}
+
 			/*read(socket_tcp, buffer_received, MAX_LINE-1);*/
 
 			/* reset buffer to get only relevant string */

commit 24a1e38819eb27dcf13120fd3a794424dd6c227b
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 18:13:52 2017 -0500

    Implement reply back to client via UDP.

diff --git a/server/server.c b/server/server.c
index 9612752..ed7d16a 100644
--- a/server/server.c
+++ b/server/server.c
@@ -142,8 +142,8 @@ int main(int argc, char *argv[]) {
 
 
 		if (strncmp(buffer, "CAP", 3) == 0) {
-		/*number of relevant bytes of message */
-		/*= buffer length - 'CAP' length - length of two line breaks - end of string */
+			/*number of relevant bytes of message */
+			/*= buffer length - 'CAP' length - length of two line breaks - end of string */
 
 			to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));
 			memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);
@@ -162,13 +162,19 @@ int main(int argc, char *argv[]) {
 
 			/*[> parse the capitalized message to send to the client <]*/
 
-			sprintf(buffer_send, "%s", to_capitalize);
+			sprintf(buffer_send, "%d", strlen(to_capitalize));
 			strcat(buffer_send, "\n");
 			strcat(buffer_send, to_capitalize);
 
+			printf("to send: %s\n", to_capitalize);
 			/*[> send the formatted message to the client <]*/
-			/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
 
+			int sentlen = 0;
+			sentlen = sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &remaddr, addrlen);
+			if (sentlen < 0) {
+				buffer_send[sentlen] = 0;
+				perror("Sending failed.");
+			}
 			/*[> free the memory <]*/
 			free(to_capitalize);
 

commit c952ea83c591d5f6e3d9d8b3b0cb715b7b74d25a
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 17:54:38 2017 -0500

    fix: typos

diff --git a/server/server.c b/server/server.c
index 40e7f96..9612752 100644
--- a/server/server.c
+++ b/server/server.c
@@ -246,3 +246,4 @@ int main(int argc, char *argv[]) {
 		/*fprintf(stderr, "Connection closed.\n");*/
 		/*}*/
 	}
+}

commit b44c24ff7e3f3474ca5629157a9ae8f7a37834cf
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 17:51:36 2017 -0500

    Implement of capitalize string and send back it to client.

diff --git a/server/server.c b/server/server.c
index c7d2dbf..40e7f96 100644
--- a/server/server.c
+++ b/server/server.c
@@ -79,28 +79,28 @@ int main(int argc, char *argv[]) {
 	/*  Set all bytes in socket address structure to*/
 	/*zero, and fill in the relevant data members   */
 
-		/*memset(&servaddr, 0, sizeof(servaddr));*/
-		/*servaddr.sin_family      = AF_INET;*/
-		/*servaddr.sin_addr.s_addr = htonl(INADDR_ANY);*/
-		/*servaddr.sin_port        = htons(port);*/
+	/*memset(&servaddr, 0, sizeof(servaddr));*/
+	/*servaddr.sin_family      = AF_INET;*/
+	/*servaddr.sin_addr.s_addr = htonl(INADDR_ANY);*/
+	/*servaddr.sin_port        = htons(port);*/
 
 
-		/*  Bind our socket addresss to the */
-		/*listening socket, and call listen()  */
+	/*  Bind our socket addresss to the */
+	/*listening socket, and call listen()  */
 
-		/*if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {*/
-		/*fprintf(stderr, "ECHOSERV: Error calling bind()\n");*/
-		/*exit(EXIT_FAILURE);*/
-		/*}*/
+	/*if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {*/
+	/*fprintf(stderr, "ECHOSERV: Error calling bind()\n");*/
+	/*exit(EXIT_FAILURE);*/
+	/*}*/
 
-		/*if ( listen(list_s, LISTENQ) < 0 ) {*/
-		/*perror("ECHOSERV: Error calling listen()\n");*/
-		/*exit(EXIT_FAILURE);*/
-		/*}*/
+	/*if ( listen(list_s, LISTENQ) < 0 ) {*/
+	/*perror("ECHOSERV: Error calling listen()\n");*/
+	/*exit(EXIT_FAILURE);*/
+	/*}*/
 
-		/*UDP Connection  */
+	/*UDP Connection  */
 
-		socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
+	socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
 
 	/*  Set all bytes in socket address structure to
 	    zero, and fill in the relevant data members   */
@@ -140,117 +140,109 @@ int main(int argc, char *argv[]) {
 		/*exit(EXIT_FAILURE);*/
 		/*}*/
 
-		/*Retrieve an input line from the connected socket*/
-		/*then simply write it back to the  same socket.     */
-		/**/
 
-			/*while (1) {*/
-			/*read(socket_tcp, buffer, MAX_LINE-1);*/
+		if (strncmp(buffer, "CAP", 3) == 0) {
+		/*number of relevant bytes of message */
+		/*= buffer length - 'CAP' length - length of two line breaks - end of string */
 
-			/*if (strncmp(buffer, "CAP", 3) == 0) {*/
-			/* number of relevant bytes of message */
-			/*= buffer length - 'CAP' length - length of two line breaks - end of string */
-			/**/
-
-			/*to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));*/
-			/*memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);*/
+			to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));
+			memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);
 
 			/*[> Capitalize the messsage <]*/
-			/*int index = 0;*/
-			/*while (to_capitalize[index] != '\0') {*/
-			/*if (islower(to_capitalize[index])) {*/
-			/*to_capitalize[index] = toupper(to_capitalize[index]);*/
-			/*}*/
-			/*else {*/
-			/*to_capitalize[index] = to_capitalize[index];*/
-			/*}*/
-			/*index++;*/
-			/*}*/
+			int index = 0;
+			while (to_capitalize[index] != '\0') {
+				if (islower(to_capitalize[index])) {
+					to_capitalize[index] = toupper(to_capitalize[index]);
+				}
+				else {
+					to_capitalize[index] = to_capitalize[index];
+				}
+				index++;
+			}
 
 			/*[> parse the capitalized message to send to the client <]*/
 
-			/*sprintf(buffer_send, "%d", strlen(to_capitalize));*/
-			/*strcat(buffer_send, "\n");*/
-			/*strcat(buffer_send, to_capitalize);*/
+			sprintf(buffer_send, "%s", to_capitalize);
+			strcat(buffer_send, "\n");
+			strcat(buffer_send, to_capitalize);
 
 			/*[> send the formatted message to the client <]*/
 			/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
 
 			/*[> free the memory <]*/
-			/*free(to_capitalize);*/
-
-			/*}*/
-
-			/*if (strncmp(buffer, "FILE", 4) == 0) {*/
-			/*file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));*/
-			/*memcpy(file_name, buffer + 5, strlen(buffer) - 6);*/
-
-			/*[> Find file name and read that file <]*/
-			/*fp = fopen(file_name, "rb");*/
-			/*if (fp) {*/
-			/*long lSize;*/
-			/*void* large_buffer;*/
-			/*size_t result;*/
-
-			/*[> obtain file size <]*/
-			/*fseek(fp, 0, SEEK_END);*/
-			/*lSize = ftell(fp);*/
-			/*rewind(fp); [> Put the postion of pointer back to the start of the file <]*/
-
-			/*[> allocate memory to hold the whole file <]*/
-			/*large_buffer = (void* ) malloc(sizeof(void*) * lSize);*/
-			/*if (large_buffer == NULL) {*/
-			/*perror("Error in allocating required memory: ");*/
-			/*}*/
-
-			/*[> copy the file into the buffer <]*/
-			/*result = fread(large_buffer, 1, lSize, fp);*/
-			/*if (result != lSize) {*/
-			/*printf("Error reading whole file.\n");*/
-			/*}*/
-
-			/*[> close the file and later free the large_buffer <]*/
-			/*fclose(fp);*/
-
-			/*[> send the buffer to the client <]*/
-			/*if (MAX_LINE < lSize) {*/
-			/*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
-			/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-			/*}*/
-			/*else {*/
-			/*sprintf(buffer_send, "%d", lSize);*/
-			/*strcat(buffer_send, "\n");*/
-			/*strcat(buffer_send, large_buffer);*/
-			/*write(socket_tcp, buffer_send, lSize);*/
-			/*}*/
+			free(to_capitalize);
 
-			/*[> free the memory <]*/
-			/*free(large_buffer);*/
-			/*free(file_name);*/
-			/*} else {*/
-			/*[> No such file <]*/
-			/*strcpy(buffer, "NOT FOUND");*/
-			/*sprintf(buffer_send, "%d", strlen(buffer));*/
-			/*strcat(buffer_send, "\n");*/
-			/*strcat(buffer_send, buffer);*/
-
-			/*[> Inform client that file is not in the server. <]*/
-			/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
-			/*}*/
+		}
+
+		/*if (strncmp(buffer, "FILE", 4) == 0) {*/
+		/*file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));*/
+		/*memcpy(file_name, buffer + 5, strlen(buffer) - 6);*/
+
+		/*[> Find file name and read that file <]*/
+		/*fp = fopen(file_name, "rb");*/
+		/*if (fp) {*/
+		/*long lSize;*/
+		/*void* large_buffer;*/
+		/*size_t result;*/
+
+		/*[> obtain file size <]*/
+		/*fseek(fp, 0, SEEK_END);*/
+		/*lSize = ftell(fp);*/
+		/*rewind(fp); [> Put the postion of pointer back to the start of the file <]*/
+
+		/*[> allocate memory to hold the whole file <]*/
+		/*large_buffer = (void* ) malloc(sizeof(void*) * lSize);*/
+		/*if (large_buffer == NULL) {*/
+		/*perror("Error in allocating required memory: ");*/
+		/*}*/
+
+		/*[> copy the file into the buffer <]*/
+		/*result = fread(large_buffer, 1, lSize, fp);*/
+		/*if (result != lSize) {*/
+		/*printf("Error reading whole file.\n");*/
+		/*}*/
+
+		/*[> close the file and later free the large_buffer <]*/
+		/*fclose(fp);*/
+
+		/*[> send the buffer to the client <]*/
+		/*if (MAX_LINE < lSize) {*/
+		/*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
+		/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+		/*}*/
+		/*else {*/
+		/*sprintf(buffer_send, "%d", lSize);*/
+		/*strcat(buffer_send, "\n");*/
+		/*strcat(buffer_send, large_buffer);*/
+		/*write(socket_tcp, buffer_send, lSize);*/
+		/*}*/
+
+		/*[> free the memory <]*/
+		/*free(large_buffer);*/
+		/*free(file_name);*/
+		/*} else {*/
+		/*[> No such file <]*/
+		/*strcpy(buffer, "NOT FOUND");*/
+		/*sprintf(buffer_send, "%d", strlen(buffer));*/
+		/*strcat(buffer_send, "\n");*/
+		/*strcat(buffer_send, buffer);*/
+
+		/*[> Inform client that file is not in the server. <]*/
+		/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+		/*}*/
 
-			/*}*/
+		/*}*/
 
-			/*   [>* free the memory */
-			memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+		/*   [>* free the memory */
+		memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
 		memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
-	}
 
-	/*  Close the connected socket  */
-	/*         if ( close(socket_tcp) < 0 ) {*/
-	/*perror("ECHOSERV: Error calling close()\n");*/
-	/*exit(EXIT_FAILURE);*/
-	/*}*/
-	/*else {*/
-	/*fprintf(stderr, "Connection closed.\n");*/
-	/*}*/
-}
+		/*  Close the connected socket  */
+		/*         if ( close(socket_tcp) < 0 ) {*/
+		/*perror("ECHOSERV: Error calling close()\n");*/
+		/*exit(EXIT_FAILURE);*/
+		/*}*/
+		/*else {*/
+		/*fprintf(stderr, "Connection closed.\n");*/
+		/*}*/
+	}

commit 2d1f06e1e35624e45bc27ca5ce94a7c053308187
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 16:30:37 2017 -0500

    fix: errors generated by commenting out.
    
    Basic UDP connection is successful.

diff --git a/client/client.c b/client/client.c
index f5cba2f..7b3dbb7 100644
--- a/client/client.c
+++ b/client/client.c
@@ -78,8 +78,8 @@ int main(int argc, char *argv[]) {
 	/*exit(EXIT_FAILURE);*/
 	/*}*/
 
-	/*/*  Set all bytes in socket address structure to*/
-	/*zero, and fill in the relevant data members   */*/
+	/*  Set all bytes in socket address structure to*/
+	/*zero, and fill in the relevant data members   */
 
 		/*memset(&servaddr, 0, sizeof(servaddr));*/
 		/*servaddr.sin_family      = AF_INET;*/
@@ -152,7 +152,7 @@ int main(int argc, char *argv[]) {
 
 			/*memcpy(buffer, buffer_received + 2, strlen(buffer_received) - 2);*/
 			/*printf("Server responded: %s", buffer);*/
-			/*        }*/
+		}
 		else if (strncmp(buffer, "t", 1) == 0) {
 			printf("\nPlease Enter a string: ");
 			fgets(buffer, MAX_LINE, stdin);
@@ -182,7 +182,7 @@ int main(int argc, char *argv[]) {
 			/*fclose(fp);*/
 			/*free(file_name);*/
 			/*}*/
-			/*      }*/
+		}
 		else if (strncmp(buffer, "q", 1) == 0) {
 			fprintf(stderr, "Now should exit.\n");
 			if (close(socket_tcp) < 0 ) {
diff --git a/server/server.c b/server/server.c
index bcd4f19..c7d2dbf 100644
--- a/server/server.c
+++ b/server/server.c
@@ -76,8 +76,8 @@ int main(int argc, char *argv[]) {
 	/*}*/
 
 
-	/*/*  Set all bytes in socket address structure to*/
-	/*zero, and fill in the relevant data members   */*/
+	/*  Set all bytes in socket address structure to*/
+	/*zero, and fill in the relevant data members   */
 
 		/*memset(&servaddr, 0, sizeof(servaddr));*/
 		/*servaddr.sin_family      = AF_INET;*/
@@ -85,8 +85,8 @@ int main(int argc, char *argv[]) {
 		/*servaddr.sin_port        = htons(port);*/
 
 
-		/*/*  Bind our socket addresss to the */
-		/*listening socket, and call listen()  */*/
+		/*  Bind our socket addresss to the */
+		/*listening socket, and call listen()  */
 
 		/*if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {*/
 		/*fprintf(stderr, "ECHOSERV: Error calling bind()\n");*/
@@ -140,18 +140,17 @@ int main(int argc, char *argv[]) {
 		/*exit(EXIT_FAILURE);*/
 		/*}*/
 
-		/*/*  */
 		/*Retrieve an input line from the connected socket*/
 		/*then simply write it back to the  same socket.     */
-		/**/*/
+		/**/
 
 			/*while (1) {*/
 			/*read(socket_tcp, buffer, MAX_LINE-1);*/
 
 			/*if (strncmp(buffer, "CAP", 3) == 0) {*/
-			/*/* number of relevant bytes of message */
+			/* number of relevant bytes of message */
 			/*= buffer length - 'CAP' length - length of two line breaks - end of string */
-			/**/*/
+			/**/
 
 			/*to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));*/
 			/*memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);*/
@@ -241,7 +240,7 @@ int main(int argc, char *argv[]) {
 
 			/*}*/
 
-			/*   [>/* free the memory */
+			/*   [>* free the memory */
 			memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
 		memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
 	}
@@ -254,5 +253,4 @@ int main(int argc, char *argv[]) {
 	/*else {*/
 	/*fprintf(stderr, "Connection closed.\n");*/
 	/*}*/
-	}
 }

commit 8c6107d210a8e88a702b624498e4f50d96f78766
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 16:19:29 2017 -0500

    test: comment out TCP logics for debugging

diff --git a/client/client.c b/client/client.c
index 943721f..f5cba2f 100644
--- a/client/client.c
+++ b/client/client.c
@@ -1,16 +1,16 @@
 /*
-  CLIENT.C
-  ==========
-  (c) Ashok Tamang, 2017
-  Email: ashok.tamang@bison.howard.edu
-  Networking and Web Programming, Spring 2017
-
-  -------------------------
-  Adapted from EchoServ by:
-  (c) Paul Griffiths, 1999
-  Email: mail@paulgriffiths.net
-  
-  Simple TCP/IP echo client.
+   CLIENT.C
+   ==========
+   (c) Ashok Tamang, 2017
+Email: ashok.tamang@bison.howard.edu
+Networking and Web Programming, Spring 2017
+
+-------------------------
+Adapted from EchoServ by:
+(c) Paul Griffiths, 1999
+Email: mail@paulgriffiths.net
+
+Simple TCP/IP echo client.
 
 */
 
@@ -39,185 +39,185 @@ int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char
 
 int main(int argc, char *argv[]) {
 
-    int       socket_tcp;                    /*  connection socket                  */
-    int	      socket_udp;
-    short int tcp_port;                   /*  tcp port number                        */
-    short int udp_port;                   /*  udp port number                    */
-    struct    sockaddr_in servaddr;       /*  socket address structure           */
-    char      buffer[MAX_LINE];           /*  character buffer                   */
-    char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
-    char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
-    char     *szAddress;                  /*  Holds remote IP address            */
-    char     *udpPort;			 /* Holds server upd port */
-    char     *tcpPort;                     /*  Holds server tcp port                  */
-    char     *endptr;                     /*  for strtol()                       */
-    FILE     *fp;                         /*  file pointer                       */
-    char     *file_name;                  /*  for creating and writing data into */
-
-
-    /*  Get command line arguments  */
-
-    ParseCmdLine(argc, argv, &szAddress, &tcpPort, &udpPort);
-
-
-    /* TCP connection */
-
-    /*  Set the remote port  */
-
-    tcp_port = strtol(tcpPort, &endptr, 0);
-    if ( *endptr ) {
-    	printf("ECHOCLNT: Invalid port supplied.\n");
-    	exit(EXIT_FAILURE);
-    }
-	
-
-    /*  Create the listening socket  */
-
-    if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
-    	fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
-    	exit(EXIT_FAILURE);
-    }
-
-    /*  Set all bytes in socket address structure to
-        zero, and fill in the relevant data members   */
-
-    memset(&servaddr, 0, sizeof(servaddr));
-    servaddr.sin_family      = AF_INET;
-    servaddr.sin_port        = htons(tcp_port);
-    
-    /*  Set the remote IP address  */
-
-    if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {
-    	printf("ECHOCLNT: Invalid remote IP address.\n");
-    	exit(EXIT_FAILURE);
-    }
-
-    
-    /*  connect() to the remote echo server  */
-
-    if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
-    	printf("ECHOCLNT: Error calling connect()\n");
-    	exit(EXIT_FAILURE);
-    }
-
-    /* UDP connection */
-
-    /*  Set the remote port  */
-    memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for udp_port */
-    udp_port = strtol(udpPort, &endptr, 0);
-    if ( *endptr ) {
-    	printf("ECHOCLNT: Invalid port supplied.\n");
-    	exit(EXIT_FAILURE);
-    }
-	
-    /*Create UDP socket*/
-
-    if ( (socket_udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
-    	fprintf(stderr, "ECHOCLNT: Error creating UDP socket.\n");
-    	exit(EXIT_FAILURE);
-    }
-
-    /*  Set all bytes in socket address structure to
-        zero, and fill in the relevant data members   */
-
-    memset(&servaddr, 0, sizeof(servaddr));
-    servaddr.sin_family      = AF_INET;
-    servaddr.sin_port        = htons(udp_port);
-    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-
-    /*  Get string to follow user commands */
-    do {
-        printf("Insert your command: ");
-        fgets(buffer, MAX_LINE, stdin);
-
-        if (strncmp(buffer, "s", 1) == 0) {
-            printf("\nPlease Enter a string: ");
-            fgets(buffer, MAX_LINE, stdin);
-            
-            /* Format the input string */
-            strcpy(buffer_send, "CAP\n");
-            strcat(buffer_send, buffer);
-            strcat(buffer_send, "\n");
-
-	    /*Send message to server via UDP*/
-	    if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
-		    perror("Send to, failed.");
-		    exit(EXIT_FAILURE);
-	    }
-	    
-            read(socket_tcp, buffer_received, MAX_LINE-1);
-
-            /* reset buffer to get only relevant string */
-            memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-            
-            memcpy(buffer, buffer_received + 2, strlen(buffer_received) - 2);
-            printf("Server responded: %s", buffer);
-        }
-        else if (strncmp(buffer, "t", 1) == 0) {
-            printf("\nPlease Enter a string: ");
-            fgets(buffer, MAX_LINE, stdin);
-            
-            file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
-            memcpy(file_name, buffer, strlen(buffer) - 1);  
-
-            /* Format the input string */
-            strcpy(buffer_send, "FILE\n");
-            strcat(buffer_send, buffer);
-
-            /* Send message to server. */
-            write(socket_tcp, buffer_send, strlen(buffer_send));
-
-            /* Read message from server. */
-            read(socket_tcp, buffer_received, MAX_LINE-1);
- 
-            /* write the data to the file. */
-            if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {
-                printf("Server responded: %s\n", buffer_received + 2);
-            }
-            else {
-                fp = fopen(file_name, "wb");
-                fwrite(buffer_received, 1, strlen(buffer_received), fp);
-                printf("Server responded: Data is written to the file named: %s\n", file_name);
-                /* close the file and free the memory */
-                fclose(fp);
-                free(file_name);
-            }
-        }
-        else if (strncmp(buffer, "q", 1) == 0) {
-            fprintf(stderr, "Now should exit.\n");
-            if (close(socket_tcp) < 0 ) {
-                fprintf(stderr, "ECHOSERV: Error calling close()\n");
-                exit(EXIT_FAILURE);
-            }
-
-            return EXIT_SUCCESS;
-        }
-        else 
-            printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
-
-        /* free the memory */
-        memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-        memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
-        memset(buffer_received, 0, (sizeof buffer_received[0]) * MAX_LINE);
-    
-    } while (strncmp(buffer, "q", 1) != 0);
-
-    return EXIT_SUCCESS;
+	int       socket_tcp;                    /*  connection socket                  */
+	int	      socket_udp;
+	short int tcp_port;                   /*  tcp port number                        */
+	short int udp_port;                   /*  udp port number                    */
+	struct    sockaddr_in servaddr;       /*  socket address structure           */
+	char      buffer[MAX_LINE];           /*  character buffer                   */
+	char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
+	char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
+	char     *szAddress;                  /*  Holds remote IP address            */
+	char     *udpPort;			 /* Holds server upd port */
+	char     *tcpPort;                     /*  Holds server tcp port                  */
+	char     *endptr;                     /*  for strtol()                       */
+	FILE     *fp;                         /*  file pointer                       */
+	char     *file_name;                  /*  for creating and writing data into */
+
+
+	/*  Get command line arguments  */
+
+	ParseCmdLine(argc, argv, &szAddress, &tcpPort, &udpPort);
+
+
+	/* TCP connection */
+
+	/*  Set the remote port  */
+
+	/*tcp_port = strtol(tcpPort, &endptr, 0);*/
+	/*if ( *endptr ) {*/
+	/*printf("ECHOCLNT: Invalid port supplied.\n");*/
+	/*exit(EXIT_FAILURE);*/
+	/*}*/
+
+
+	/*[>  Create the listening socket  <]*/
+
+	/*if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
+	/*fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");*/
+	/*exit(EXIT_FAILURE);*/
+	/*}*/
+
+	/*/*  Set all bytes in socket address structure to*/
+	/*zero, and fill in the relevant data members   */*/
+
+		/*memset(&servaddr, 0, sizeof(servaddr));*/
+		/*servaddr.sin_family      = AF_INET;*/
+		/*servaddr.sin_port        = htons(tcp_port);*/
+
+		/*[>  Set the remote IP address  <]*/
+
+		/*if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {*/
+		/*printf("ECHOCLNT: Invalid remote IP address.\n");*/
+		/*exit(EXIT_FAILURE);*/
+		/*}*/
+
+
+		/*[>  connect() to the remote echo server  <]*/
+
+		/*if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {*/
+		/*perror("Connection failed");*/
+		/*exit(EXIT_FAILURE);*/
+		/*}*/
+
+		/* UDP connection */
+
+		/*  Set the remote port  */
+		memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for udp_port */
+	udp_port = strtol(udpPort, &endptr, 0);
+	if ( *endptr ) {
+		printf("ECHOCLNT: Invalid port supplied.\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/*Create UDP socket*/
+
+	if ( (socket_udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
+		fprintf(stderr, "ECHOCLNT: Error creating UDP socket.\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/*  Set all bytes in socket address structure to
+	    zero, and fill in the relevant data members   */
+
+	memset(&servaddr, 0, sizeof(servaddr));
+	servaddr.sin_family      = AF_INET;
+	servaddr.sin_port        = htons(udp_port);
+	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+
+	/*  Get string to follow user commands */
+	do {
+		printf("Insert your command: ");
+		fgets(buffer, MAX_LINE, stdin);
+
+		if (strncmp(buffer, "s", 1) == 0) {
+			printf("\nPlease Enter a string: ");
+			fgets(buffer, MAX_LINE, stdin);
+
+			/* Format the input string */
+			strcpy(buffer_send, "CAP\n");
+			strcat(buffer_send, buffer);
+			strcat(buffer_send, "\n");
+
+			/*Send message to server via UDP*/
+			if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
+				perror("Send to, failed.");
+				exit(EXIT_FAILURE);
+			}
+
+			/*read(socket_tcp, buffer_received, MAX_LINE-1);*/
+
+			/* reset buffer to get only relevant string */
+			/*            memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);*/
+
+			/*memcpy(buffer, buffer_received + 2, strlen(buffer_received) - 2);*/
+			/*printf("Server responded: %s", buffer);*/
+			/*        }*/
+		else if (strncmp(buffer, "t", 1) == 0) {
+			printf("\nPlease Enter a string: ");
+			fgets(buffer, MAX_LINE, stdin);
+
+			file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
+			memcpy(file_name, buffer, strlen(buffer) - 1);  
+
+			/* Format the input string */
+			strcpy(buffer_send, "FILE\n");
+			strcat(buffer_send, buffer);
+
+			/* Send message to server. */
+			/*          write(socket_tcp, buffer_send, strlen(buffer_send));*/
+
+			/*[> Read message from server. <]*/
+			/*read(socket_tcp, buffer_received, MAX_LINE-1);*/
+
+			/*[> write the data to the file. <]*/
+			/*if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {*/
+			/*printf("Server responded: %s\n", buffer_received + 2);*/
+			/*}*/
+			/*else {*/
+			/*fp = fopen(file_name, "wb");*/
+			/*fwrite(buffer_received, 1, strlen(buffer_received), fp);*/
+			/*printf("Server responded: Data is written to the file named: %s\n", file_name);*/
+			/*[> close the file and free the memory <]*/
+			/*fclose(fp);*/
+			/*free(file_name);*/
+			/*}*/
+			/*      }*/
+		else if (strncmp(buffer, "q", 1) == 0) {
+			fprintf(stderr, "Now should exit.\n");
+			if (close(socket_tcp) < 0 ) {
+				fprintf(stderr, "ECHOSERV: Error calling close()\n");
+				exit(EXIT_FAILURE);
+			}
+
+			return EXIT_SUCCESS;
+		}
+		else 
+			printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
+
+		/* free the memory */
+		memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+		memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
+		memset(buffer_received, 0, (sizeof buffer_received[0]) * MAX_LINE);
+
+	} while (strncmp(buffer, "q", 1) != 0);
+
+	return EXIT_SUCCESS;
 }
 
 
 int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort) {
-    /* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
-    if (argc == 4) {
-	*tcpPort = argv[1];
-        *szAddress = argv[2];
-	*udpPort = argv[3];
-    }
+	/* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
+	if (argc == 4) {
+		*tcpPort = argv[1];
+		*szAddress = argv[2];
+		*udpPort = argv[3];
+	}
 	else {
-	    printf("Usage:\n\n");
-	    printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
-	    exit(EXIT_SUCCESS);
+		printf("Usage:\n\n");
+		printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
+		exit(EXIT_SUCCESS);
 	}
-    return 0;
+	return 0;
 }
 
diff --git a/server/server.c b/server/server.c
index 1e4430e..bcd4f19 100644
--- a/server/server.c
+++ b/server/server.c
@@ -69,38 +69,38 @@ int main(int argc, char *argv[]) {
 	/* TCP connection */	
 	/*  Create the listening socket  */
 
-	if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
-		perror("ECHOSERV: Error creating listening socket.\n");
+	/* if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {*/
+	/*perror("ECHOSERV: Error creating listening socket.\n");*/
 
-		exit(EXIT_FAILURE);
-	}
+	/*exit(EXIT_FAILURE);*/
+	/*}*/
 
 
-	/*  Set all bytes in socket address structure to
-	    zero, and fill in the relevant data members   */
+	/*/*  Set all bytes in socket address structure to*/
+	/*zero, and fill in the relevant data members   */*/
 
-	memset(&servaddr, 0, sizeof(servaddr));
-	servaddr.sin_family      = AF_INET;
-	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-	servaddr.sin_port        = htons(port);
+		/*memset(&servaddr, 0, sizeof(servaddr));*/
+		/*servaddr.sin_family      = AF_INET;*/
+		/*servaddr.sin_addr.s_addr = htonl(INADDR_ANY);*/
+		/*servaddr.sin_port        = htons(port);*/
 
 
-	/*  Bind our socket addresss to the 
-	    listening socket, and call listen()  */
+		/*/*  Bind our socket addresss to the */
+		/*listening socket, and call listen()  */*/
 
-	if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
-		fprintf(stderr, "ECHOSERV: Error calling bind()\n");
-		exit(EXIT_FAILURE);
-	}
+		/*if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {*/
+		/*fprintf(stderr, "ECHOSERV: Error calling bind()\n");*/
+		/*exit(EXIT_FAILURE);*/
+		/*}*/
 
-	if ( listen(list_s, LISTENQ) < 0 ) {
-		perror("ECHOSERV: Error calling listen()\n");
-		exit(EXIT_FAILURE);
-	}
+		/*if ( listen(list_s, LISTENQ) < 0 ) {*/
+		/*perror("ECHOSERV: Error calling listen()\n");*/
+		/*exit(EXIT_FAILURE);*/
+		/*}*/
+
+		/*UDP Connection  */
 
-	/*UDP Connection  */
-	
-	socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
+		socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
 
 	/*  Set all bytes in socket address structure to
 	    zero, and fill in the relevant data members   */
@@ -132,127 +132,127 @@ int main(int argc, char *argv[]) {
 			buffer[recvlen] = 0;
 			printf("received message: \"%s\"\n", buffer);
 		}
-		
-		/*  Wait for a connection, then accept() it  */
 
-		if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {
-			fprintf(stderr, "ECHOSERV: Error calling accept()\n");
-			exit(EXIT_FAILURE);
-		}
+		/*  Wait for a connection, then accept() it  */
 
-		/*  
-		    Retrieve an input line from the connected socket
-		    then simply write it back to the  same socket.     
-		    */
-
-		while (1) {
-			read(socket_tcp, buffer, MAX_LINE-1);
-
-			if (strncmp(buffer, "CAP", 3) == 0) {
-				/* number of relevant bytes of message 
-				   = buffer length - 'CAP' length - length of two line breaks - end of string 
-				   */
-
-				to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));
-				memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);
-
-				/* Capitalize the messsage */
-				int index = 0;
-				while (to_capitalize[index] != '\0') {
-					if (islower(to_capitalize[index])) {
-						to_capitalize[index] = toupper(to_capitalize[index]);
-					}
-					else {
-						to_capitalize[index] = to_capitalize[index];
-					}
-					index++;
-				}
-
-				/* parse the capitalized message to send to the client */
-
-				sprintf(buffer_send, "%d", strlen(to_capitalize));
-				strcat(buffer_send, "\n");
-				strcat(buffer_send, to_capitalize);
-
-				/* send the formatted message to the client */
-				write(socket_tcp, buffer_send, strlen(buffer_send));
-
-				/* free the memory */
-				free(to_capitalize);
-
-			}
-
-			if (strncmp(buffer, "FILE", 4) == 0) {
-				file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));
-				memcpy(file_name, buffer + 5, strlen(buffer) - 6);
-
-				/* Find file name and read that file */
-				fp = fopen(file_name, "rb");
-				if (fp) {
-					long lSize;
-					void* large_buffer;
-					size_t result;
-
-					/* obtain file size */
-					fseek(fp, 0, SEEK_END);
-					lSize = ftell(fp);
-					rewind(fp); /* Put the postion of pointer back to the start of the file */
-
-					/* allocate memory to hold the whole file */
-					large_buffer = (void* ) malloc(sizeof(void*) * lSize);
-					if (large_buffer == NULL) {
-						perror("Error in allocating required memory: ");
-					}
-
-					/* copy the file into the buffer */
-					result = fread(large_buffer, 1, lSize, fp);
-					if (result != lSize) {
-						printf("Error reading whole file.\n");
-					}
-
-					/* close the file and later free the large_buffer */
-					fclose(fp);
-
-					/* send the buffer to the client */
-					if (MAX_LINE < lSize) {
-						strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");
-						write(socket_tcp, buffer_send, strlen(buffer_send));
-					}
-					else {
-						sprintf(buffer_send, "%d", lSize);
-						strcat(buffer_send, "\n");
-						strcat(buffer_send, large_buffer);
-						write(socket_tcp, buffer_send, lSize);
-					}
-
-					/* free the memory */
-					free(large_buffer);
-					free(file_name);
-				} else {
-					/* No such file */
-					strcpy(buffer, "NOT FOUND");
-					sprintf(buffer_send, "%d", strlen(buffer));
-					strcat(buffer_send, "\n");
-					strcat(buffer_send, buffer);
-
-					/* Inform client that file is not in the server. */
-					write(socket_tcp, buffer_send, strlen(buffer_send));
-				}
-
-			}
-
-			/* free the memory */
+		/*         if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {*/
+		/*fprintf(stderr, "ECHOSERV: Error calling accept()\n");*/
+		/*exit(EXIT_FAILURE);*/
+		/*}*/
+
+		/*/*  */
+		/*Retrieve an input line from the connected socket*/
+		/*then simply write it back to the  same socket.     */
+		/**/*/
+
+			/*while (1) {*/
+			/*read(socket_tcp, buffer, MAX_LINE-1);*/
+
+			/*if (strncmp(buffer, "CAP", 3) == 0) {*/
+			/*/* number of relevant bytes of message */
+			/*= buffer length - 'CAP' length - length of two line breaks - end of string */
+			/**/*/
+
+			/*to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));*/
+			/*memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);*/
+
+			/*[> Capitalize the messsage <]*/
+			/*int index = 0;*/
+			/*while (to_capitalize[index] != '\0') {*/
+			/*if (islower(to_capitalize[index])) {*/
+			/*to_capitalize[index] = toupper(to_capitalize[index]);*/
+			/*}*/
+			/*else {*/
+			/*to_capitalize[index] = to_capitalize[index];*/
+			/*}*/
+			/*index++;*/
+			/*}*/
+
+			/*[> parse the capitalized message to send to the client <]*/
+
+			/*sprintf(buffer_send, "%d", strlen(to_capitalize));*/
+			/*strcat(buffer_send, "\n");*/
+			/*strcat(buffer_send, to_capitalize);*/
+
+			/*[> send the formatted message to the client <]*/
+			/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+
+			/*[> free the memory <]*/
+			/*free(to_capitalize);*/
+
+			/*}*/
+
+			/*if (strncmp(buffer, "FILE", 4) == 0) {*/
+			/*file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));*/
+			/*memcpy(file_name, buffer + 5, strlen(buffer) - 6);*/
+
+			/*[> Find file name and read that file <]*/
+			/*fp = fopen(file_name, "rb");*/
+			/*if (fp) {*/
+			/*long lSize;*/
+			/*void* large_buffer;*/
+			/*size_t result;*/
+
+			/*[> obtain file size <]*/
+			/*fseek(fp, 0, SEEK_END);*/
+			/*lSize = ftell(fp);*/
+			/*rewind(fp); [> Put the postion of pointer back to the start of the file <]*/
+
+			/*[> allocate memory to hold the whole file <]*/
+			/*large_buffer = (void* ) malloc(sizeof(void*) * lSize);*/
+			/*if (large_buffer == NULL) {*/
+			/*perror("Error in allocating required memory: ");*/
+			/*}*/
+
+			/*[> copy the file into the buffer <]*/
+			/*result = fread(large_buffer, 1, lSize, fp);*/
+			/*if (result != lSize) {*/
+			/*printf("Error reading whole file.\n");*/
+			/*}*/
+
+			/*[> close the file and later free the large_buffer <]*/
+			/*fclose(fp);*/
+
+			/*[> send the buffer to the client <]*/
+			/*if (MAX_LINE < lSize) {*/
+			/*strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");*/
+			/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+			/*}*/
+			/*else {*/
+			/*sprintf(buffer_send, "%d", lSize);*/
+			/*strcat(buffer_send, "\n");*/
+			/*strcat(buffer_send, large_buffer);*/
+			/*write(socket_tcp, buffer_send, lSize);*/
+			/*}*/
+
+			/*[> free the memory <]*/
+			/*free(large_buffer);*/
+			/*free(file_name);*/
+			/*} else {*/
+			/*[> No such file <]*/
+			/*strcpy(buffer, "NOT FOUND");*/
+			/*sprintf(buffer_send, "%d", strlen(buffer));*/
+			/*strcat(buffer_send, "\n");*/
+			/*strcat(buffer_send, buffer);*/
+
+			/*[> Inform client that file is not in the server. <]*/
+			/*write(socket_tcp, buffer_send, strlen(buffer_send));*/
+			/*}*/
+
+			/*}*/
+
+			/*   [>/* free the memory */
 			memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-			memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
-		}
+		memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
+	}
 
-		/*  Close the connected socket  */
-		if ( close(socket_tcp) < 0 ) {
-			perror("ECHOSERV: Error calling close()\n");
-			exit(EXIT_FAILURE);
-		}
-		else {
-			fprintf(stderr, "Connection closed.\n");
-		}
+	/*  Close the connected socket  */
+	/*         if ( close(socket_tcp) < 0 ) {*/
+	/*perror("ECHOSERV: Error calling close()\n");*/
+	/*exit(EXIT_FAILURE);*/
+	/*}*/
+	/*else {*/
+	/*fprintf(stderr, "Connection closed.\n");*/
+	/*}*/
 	}
 }

commit 48e09fa1c4f375da5e72646d04617c4aca68cfcd
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 16:05:49 2017 -0500

    fix: typos in sendto() and recvfrom() usage.

diff --git a/client/client.c b/client/client.c
index 60ba814..943721f 100644
--- a/client/client.c
+++ b/client/client.c
@@ -140,7 +140,7 @@ int main(int argc, char *argv[]) {
             strcat(buffer_send, "\n");
 
 	    /*Send message to server via UDP*/
-	    if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *), sizeof(servaddr)) < 0) {
+	    if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
 		    perror("Send to, failed.");
 		    exit(EXIT_FAILURE);
 	    }
diff --git a/server/server.c b/server/server.c
index f4ba4c0..1e4430e 100644
--- a/server/server.c
+++ b/server/server.c
@@ -41,7 +41,7 @@ int main(int argc, char *argv[]) {
 	short int port;                  /*  port number: UDP               */
 	struct    sockaddr_in servaddr;  /*  socket address structure  */
 	struct sockaddr_in remaddr;  /* remote address */
-	socklen_t addren = sizeof(remaddr); /* length of remote address */
+	socklen_t addrlen = sizeof(remaddr); /* length of remote address */
 	char      buffer[MAX_LINE];      /*  character buffer          */
 	char      buffer_send[MAX_LINE];
 	char     *endptr;                /*  for strtol()              */
@@ -126,7 +126,7 @@ int main(int argc, char *argv[]) {
 		/*UDP connection*/
 		printf("Waiting on port %d\n", port);
 		int recvlen = 0;
-		recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, $addrlen);
+		recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, &addrlen);
 		printf("recieved %d bytes\n", recvlen);
 		if (recvlen > 0) {
 			buffer[recvlen] = 0;

commit 22a927e38af8c7da388965a80f577a35fb1c3354
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 16:00:53 2017 -0500

    Send message from client to server via UDP.

diff --git a/client/client.c b/client/client.c
index dab0dc9..60ba814 100644
--- a/client/client.c
+++ b/client/client.c
@@ -100,7 +100,7 @@ int main(int argc, char *argv[]) {
     	exit(EXIT_FAILURE);
     }
 
-    /* UDP connectin */
+    /* UDP connection */
 
     /*  Set the remote port  */
     memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for udp_port */
@@ -110,11 +110,10 @@ int main(int argc, char *argv[]) {
     	exit(EXIT_FAILURE);
     }
 	
-
-    /*  Create the listening socket  */
+    /*Create UDP socket*/
 
     if ( (socket_udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
-    	fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
+    	fprintf(stderr, "ECHOCLNT: Error creating UDP socket.\n");
     	exit(EXIT_FAILURE);
     }
 
@@ -140,7 +139,12 @@ int main(int argc, char *argv[]) {
             strcat(buffer_send, buffer);
             strcat(buffer_send, "\n");
 
-            write(socket_tcp, buffer_send, strlen(buffer_send));
+	    /*Send message to server via UDP*/
+	    if (sendto(socket_udp, buffer_send, strlen(buffer_send), 0, (struct sockaddr *), sizeof(servaddr)) < 0) {
+		    perror("Send to, failed.");
+		    exit(EXIT_FAILURE);
+	    }
+	    
             read(socket_tcp, buffer_received, MAX_LINE-1);
 
             /* reset buffer to get only relevant string */
diff --git a/server/server.c b/server/server.c
index 778916a..f4ba4c0 100644
--- a/server/server.c
+++ b/server/server.c
@@ -40,6 +40,8 @@ int main(int argc, char *argv[]) {
 	int       list_s;                /*  listening socket          */
 	short int port;                  /*  port number: UDP               */
 	struct    sockaddr_in servaddr;  /*  socket address structure  */
+	struct sockaddr_in remaddr;  /* remote address */
+	socklen_t addren = sizeof(remaddr); /* length of remote address */
 	char      buffer[MAX_LINE];      /*  character buffer          */
 	char      buffer_send[MAX_LINE];
 	char     *endptr;                /*  for strtol()              */
@@ -121,6 +123,16 @@ int main(int argc, char *argv[]) {
 	/*  Enter an infinite loop to respond to client requests.  */
 
 	while ( 1 ) {
+		/*UDP connection*/
+		printf("Waiting on port %d\n", port);
+		int recvlen = 0;
+		recvlen = recvfrom(socket_udp, buffer, MAX_LINE, 0, (struct sockaddr *) &remaddr, $addrlen);
+		printf("recieved %d bytes\n", recvlen);
+		if (recvlen > 0) {
+			buffer[recvlen] = 0;
+			printf("received message: \"%s\"\n", buffer);
+		}
+		
 		/*  Wait for a connection, then accept() it  */
 
 		if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {

commit 21d9d8ba2cef746acc4cc1f17dd33b2c5c164ca3
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 15:35:58 2017 -0500

    Connection between client and server.

diff --git a/client/client.c b/client/client.c
index 05e3131..dab0dc9 100644
--- a/client/client.c
+++ b/client/client.c
@@ -124,23 +124,7 @@ int main(int argc, char *argv[]) {
     memset(&servaddr, 0, sizeof(servaddr));
     servaddr.sin_family      = AF_INET;
     servaddr.sin_port        = htons(udp_port);
-    servaddr.sin_addr        -= htonl(INADDR_ANY);
-
-    /*  Set the remote IP address  */
-
-    /*if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {*/
-            /*printf("ECHOCLNT: Invalid remote IP address.\n");*/
-            /*exit(EXIT_FAILURE);*/
-    /*}*/
-
-    
-    /*[>  connect() to the remote echo server  <]*/
-
-    /*if ( connect(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {*/
-            /*printf("ECHOCLNT: Error calling connect()\n");*/
-            /*exit(EXIT_FAILURE);*/
-    /*}*/
-
+    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
 
     /*  Get string to follow user commands */
     do {

commit 4b9a7246712b931c79cf23297bc18c7cbfab4f43
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 15:16:55 2017 -0500

    Initialize UDP socket in server.

diff --git a/client/client.c b/client/client.c
index 4bbc8ff..05e3131 100644
--- a/client/client.c
+++ b/client/client.c
@@ -124,22 +124,22 @@ int main(int argc, char *argv[]) {
     memset(&servaddr, 0, sizeof(servaddr));
     servaddr.sin_family      = AF_INET;
     servaddr.sin_port        = htons(udp_port);
-
+    servaddr.sin_addr        -= htonl(INADDR_ANY);
 
     /*  Set the remote IP address  */
 
-    if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {
-    	printf("ECHOCLNT: Invalid remote IP address.\n");
-    	exit(EXIT_FAILURE);
-    }
+    /*if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {*/
+            /*printf("ECHOCLNT: Invalid remote IP address.\n");*/
+            /*exit(EXIT_FAILURE);*/
+    /*}*/
 
     
-    /*  connect() to the remote echo server  */
+    /*[>  connect() to the remote echo server  <]*/
 
-    if ( connect(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
-    	printf("ECHOCLNT: Error calling connect()\n");
-    	exit(EXIT_FAILURE);
-    }
+    /*if ( connect(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {*/
+            /*printf("ECHOCLNT: Error calling connect()\n");*/
+            /*exit(EXIT_FAILURE);*/
+    /*}*/
 
 
     /*  Get string to follow user commands */
diff --git a/server/server.c b/server/server.c
index a26f05e..778916a 100644
--- a/server/server.c
+++ b/server/server.c
@@ -1,17 +1,17 @@
 /*
 
-  SERVER.C
-  ==========
-  (c) Ashok Tamang, 2017
-  Email: ashok.tamang@bison.howard.edu
-  Networking and Web Programming, Spring 2017
-
-  -------------------------
-  Adapted from EchoServ by:
-  (c) Paul Griffiths, 1999
-  Email: mail@paulgriffiths.net
-  
-  Simple TCP/IP echo server.
+   SERVER.C
+   ==========
+   (c) Ashok Tamang, 2017
+Email: ashok.tamang@bison.howard.edu
+Networking and Web Programming, Spring 2017
+
+-------------------------
+Adapted from EchoServ by:
+(c) Paul Griffiths, 1999
+Email: mail@paulgriffiths.net
+
+Simple TCP/IP echo server.
 
 */
 
@@ -35,190 +35,212 @@
 
 
 int main(int argc, char *argv[]) {
-    int       list_s;                /*  listening socket          */
-    int       conn_s;                /*  connection socket         */
-    short int port;                  /*  port number               */
-    struct    sockaddr_in servaddr;  /*  socket address structure  */
-    char      buffer[MAX_LINE];      /*  character buffer          */
-    char      buffer_send[MAX_LINE];
-    char     *endptr;                /*  for strtol()              */
-    char     *to_capitalize;         /*  store user string to capitalize */
-    char     *file_name;             /*  for storing file_name to be searched in the server */
-    FILE     *fp;                    /*  file pointer */
-
-
-    /*  Get port number from the command line.*/
-
-    if ( argc == 2 ) {
-    	port = strtol(argv[1], &endptr, 0);
-    	if ( *endptr ) {
-    	    fprintf(stderr, "ECHOSERV: Invalid port number.\n");
-    	    exit(EXIT_FAILURE);
-	   }
-    }
-    else {
-    	fprintf(stderr, "ECHOSERV: Invalid arguments.\n");
-        printf("Usage:\n\n");
-        printf("    <server> <remote Port>\n\n");
-    	exit(EXIT_FAILURE);
-    }
-
+	int       socket_tcp;                    /*  connection socket                  */
+	int	      socket_udp;
+	int       list_s;                /*  listening socket          */
+	short int port;                  /*  port number: UDP               */
+	struct    sockaddr_in servaddr;  /*  socket address structure  */
+	char      buffer[MAX_LINE];      /*  character buffer          */
+	char      buffer_send[MAX_LINE];
+	char     *endptr;                /*  for strtol()              */
+	char     *to_capitalize;         /*  store user string to capitalize */
+	char     *file_name;             /*  for storing file_name to be searched in the server */
+	FILE     *fp;                    /*  file pointer */
+
+
+	/*  Get port number from the command line.*/
+
+	if ( argc == 2 ) {
+		port = strtol(argv[1], &endptr, 0);
+		if ( *endptr ) {
+			fprintf(stderr, "ECHOSERV: Invalid port number.\n");
+			exit(EXIT_FAILURE);
+		}
+	}
+	else {
+		fprintf(stderr, "ECHOSERV: Invalid arguments.\n");
+		printf("Usage:\n\n");
+		printf("    <server> <remote Port>\n\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/* TCP connection */	
+	/*  Create the listening socket  */
+
+	if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+		perror("ECHOSERV: Error creating listening socket.\n");
+
+		exit(EXIT_FAILURE);
+	}
+
+
+	/*  Set all bytes in socket address structure to
+	    zero, and fill in the relevant data members   */
+
+	memset(&servaddr, 0, sizeof(servaddr));
+	servaddr.sin_family      = AF_INET;
+	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	servaddr.sin_port        = htons(port);
+
+
+	/*  Bind our socket addresss to the 
+	    listening socket, and call listen()  */
+
+	if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
+		fprintf(stderr, "ECHOSERV: Error calling bind()\n");
+		exit(EXIT_FAILURE);
+	}
+
+	if ( listen(list_s, LISTENQ) < 0 ) {
+		perror("ECHOSERV: Error calling listen()\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/*UDP Connection  */
 	
-    /*  Create the listening socket  */
-
-    if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
-    	perror("ECHOSERV: Error creating listening socket.\n");
-
-    	exit(EXIT_FAILURE);
-    }
-
-
-    /*  Set all bytes in socket address structure to
-        zero, and fill in the relevant data members   */
-
-    memset(&servaddr, 0, sizeof(servaddr));
-    servaddr.sin_family      = AF_INET;
-    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-    servaddr.sin_port        = htons(port);
-
-
-    /*  Bind our socket addresss to the 
-	listening socket, and call listen()  */
-
-    if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
-    	fprintf(stderr, "ECHOSERV: Error calling bind()\n");
-    	exit(EXIT_FAILURE);
-    }
-
-    if ( listen(list_s, LISTENQ) < 0 ) {
-    	perror("ECHOSERV: Error calling listen()\n");
-    	exit(EXIT_FAILURE);
-     }
-
-    
-    /*  Enter an infinite loop to respond to client requests.  */
-
-    while ( 1 ) {
-    	/*  Wait for a connection, then accept() it  */
-
-    	if ( (conn_s = accept(list_s, NULL, NULL) ) < 0 ) {
-    	    fprintf(stderr, "ECHOSERV: Error calling accept()\n");
-    	    exit(EXIT_FAILURE);
-    	}
-
-        /*  
-          Retrieve an input line from the connected socket
-          then simply write it back to the  same socket.     
-        */
-
-        while (1) {
-            read(conn_s, buffer, MAX_LINE-1);
-
-            if (strncmp(buffer, "CAP", 3) == 0) {
-                /* number of relevant bytes of message 
-                   = buffer length - 'CAP' length - length of two line breaks - end of string 
-                */
-
-                to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));
-                memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);
-
-                /* Capitalize the messsage */
-                int index = 0;
-                while (to_capitalize[index] != '\0') {
-                    if (islower(to_capitalize[index])) {
-                        to_capitalize[index] = toupper(to_capitalize[index]);
-                    }
-                    else {
-                        to_capitalize[index] = to_capitalize[index];
-                    }
-                    index++;
-                }
-
-                /* parse the capitalized message to send to the client */
-                
-                sprintf(buffer_send, "%d", strlen(to_capitalize));
-                strcat(buffer_send, "\n");
-                strcat(buffer_send, to_capitalize);
-
-                /* send the formatted message to the client */
-                write(conn_s, buffer_send, strlen(buffer_send));
-
-                /* free the memory */
-                free(to_capitalize);
-                
-            }
-
-            if (strncmp(buffer, "FILE", 4) == 0) {
-                file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));
-                memcpy(file_name, buffer + 5, strlen(buffer) - 6);
-
-                /* Find file name and read that file */
-                fp = fopen(file_name, "rb");
-                if (fp) {
-                    long lSize;
-                    void* large_buffer;
-                    size_t result;
-
-                    /* obtain file size */
-                    fseek(fp, 0, SEEK_END);
-                    lSize = ftell(fp);
-                    rewind(fp); /* Put the postion of pointer back to the start of the file */
-
-                    /* allocate memory to hold the whole file */
-                    large_buffer = (void* ) malloc(sizeof(void*) * lSize);
-                    if (large_buffer == NULL) {
-                        perror("Error in allocating required memory: ");
-                    }
-
-                    /* copy the file into the buffer */
-                    result = fread(large_buffer, 1, lSize, fp);
-                    if (result != lSize) {
-                        printf("Error reading whole file.\n");
-                    }
-
-                    /* close the file and later free the large_buffer */
-                    fclose(fp);
-
-                    /* send the buffer to the client */
-                    if (MAX_LINE < lSize) {
-                        strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");
-                        write(conn_s, buffer_send, strlen(buffer_send));
-                    }
-                    else {
-                        sprintf(buffer_send, "%d", lSize);
-                        strcat(buffer_send, "\n");
-                        strcat(buffer_send, large_buffer);
-                        write(conn_s, buffer_send, lSize);
-                    }
-
-                    /* free the memory */
-                    free(large_buffer);
-                    free(file_name);
-                } else {
-                    /* No such file */
-                    strcpy(buffer, "NOT FOUND");
-                    sprintf(buffer_send, "%d", strlen(buffer));
-                    strcat(buffer_send, "\n");
-                    strcat(buffer_send, buffer);
-
-                    /* Inform client that file is not in the server. */
-                    write(conn_s, buffer_send, strlen(buffer_send));
-                }
-
-            }
-
-            /* free the memory */
-            memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
-            memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
-        }
-
-    	/*  Close the connected socket  */
-    	if ( close(conn_s) < 0 ) {
-    	    perror("ECHOSERV: Error calling close()\n");
-    	    exit(EXIT_FAILURE);
-    	}
-        else {
-            fprintf(stderr, "Connection closed.\n");
-        }
-    }
+	socket_udp = socket(AF_INET, SOCK_DGRAM, 0);
+
+	/*  Set all bytes in socket address structure to
+	    zero, and fill in the relevant data members   */
+
+	memset(&servaddr, 0, sizeof(servaddr));
+	servaddr.sin_family      = AF_INET;
+	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	servaddr.sin_port        = htons(port);
+
+
+	/*  Bind our socket addresss to the 
+	    listening socket, and call listen()  */
+
+	if ( bind(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
+		fprintf(stderr, "ECHOSERV: Error calling bind()\n");
+		exit(EXIT_FAILURE);
+	}
+
+
+	/*  Enter an infinite loop to respond to client requests.  */
+
+	while ( 1 ) {
+		/*  Wait for a connection, then accept() it  */
+
+		if ( (socket_tcp = accept(list_s, NULL, NULL) ) < 0 ) {
+			fprintf(stderr, "ECHOSERV: Error calling accept()\n");
+			exit(EXIT_FAILURE);
+		}
+
+		/*  
+		    Retrieve an input line from the connected socket
+		    then simply write it back to the  same socket.     
+		    */
+
+		while (1) {
+			read(socket_tcp, buffer, MAX_LINE-1);
+
+			if (strncmp(buffer, "CAP", 3) == 0) {
+				/* number of relevant bytes of message 
+				   = buffer length - 'CAP' length - length of two line breaks - end of string 
+				   */
+
+				to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));
+				memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);
+
+				/* Capitalize the messsage */
+				int index = 0;
+				while (to_capitalize[index] != '\0') {
+					if (islower(to_capitalize[index])) {
+						to_capitalize[index] = toupper(to_capitalize[index]);
+					}
+					else {
+						to_capitalize[index] = to_capitalize[index];
+					}
+					index++;
+				}
+
+				/* parse the capitalized message to send to the client */
+
+				sprintf(buffer_send, "%d", strlen(to_capitalize));
+				strcat(buffer_send, "\n");
+				strcat(buffer_send, to_capitalize);
+
+				/* send the formatted message to the client */
+				write(socket_tcp, buffer_send, strlen(buffer_send));
+
+				/* free the memory */
+				free(to_capitalize);
+
+			}
+
+			if (strncmp(buffer, "FILE", 4) == 0) {
+				file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));
+				memcpy(file_name, buffer + 5, strlen(buffer) - 6);
+
+				/* Find file name and read that file */
+				fp = fopen(file_name, "rb");
+				if (fp) {
+					long lSize;
+					void* large_buffer;
+					size_t result;
+
+					/* obtain file size */
+					fseek(fp, 0, SEEK_END);
+					lSize = ftell(fp);
+					rewind(fp); /* Put the postion of pointer back to the start of the file */
+
+					/* allocate memory to hold the whole file */
+					large_buffer = (void* ) malloc(sizeof(void*) * lSize);
+					if (large_buffer == NULL) {
+						perror("Error in allocating required memory: ");
+					}
+
+					/* copy the file into the buffer */
+					result = fread(large_buffer, 1, lSize, fp);
+					if (result != lSize) {
+						printf("Error reading whole file.\n");
+					}
+
+					/* close the file and later free the large_buffer */
+					fclose(fp);
+
+					/* send the buffer to the client */
+					if (MAX_LINE < lSize) {
+						strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");
+						write(socket_tcp, buffer_send, strlen(buffer_send));
+					}
+					else {
+						sprintf(buffer_send, "%d", lSize);
+						strcat(buffer_send, "\n");
+						strcat(buffer_send, large_buffer);
+						write(socket_tcp, buffer_send, lSize);
+					}
+
+					/* free the memory */
+					free(large_buffer);
+					free(file_name);
+				} else {
+					/* No such file */
+					strcpy(buffer, "NOT FOUND");
+					sprintf(buffer_send, "%d", strlen(buffer));
+					strcat(buffer_send, "\n");
+					strcat(buffer_send, buffer);
+
+					/* Inform client that file is not in the server. */
+					write(socket_tcp, buffer_send, strlen(buffer_send));
+				}
+
+			}
+
+			/* free the memory */
+			memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+			memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
+		}
+
+		/*  Close the connected socket  */
+		if ( close(socket_tcp) < 0 ) {
+			perror("ECHOSERV: Error calling close()\n");
+			exit(EXIT_FAILURE);
+		}
+		else {
+			fprintf(stderr, "Connection closed.\n");
+		}
+	}
 }

commit 013d5e75d6bb5422c403d45b6b83b5a94a5fcb58
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 13:41:51 2017 -0500

    Initialize socket for UDP connection in client.

diff --git a/client/client.c b/client/client.c
index 81178f6..4bbc8ff 100644
--- a/client/client.c
+++ b/client/client.c
@@ -60,6 +60,8 @@ int main(int argc, char *argv[]) {
     ParseCmdLine(argc, argv, &szAddress, &tcpPort, &udpPort);
 
 
+    /* TCP connection */
+
     /*  Set the remote port  */
 
     tcp_port = strtol(tcpPort, &endptr, 0);
@@ -82,6 +84,46 @@ int main(int argc, char *argv[]) {
     memset(&servaddr, 0, sizeof(servaddr));
     servaddr.sin_family      = AF_INET;
     servaddr.sin_port        = htons(tcp_port);
+    
+    /*  Set the remote IP address  */
+
+    if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {
+    	printf("ECHOCLNT: Invalid remote IP address.\n");
+    	exit(EXIT_FAILURE);
+    }
+
+    
+    /*  connect() to the remote echo server  */
+
+    if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
+    	printf("ECHOCLNT: Error calling connect()\n");
+    	exit(EXIT_FAILURE);
+    }
+
+    /* UDP connectin */
+
+    /*  Set the remote port  */
+    memset(&endptr, 0, sizeof(endptr)); /* Reset endptr for udp_port */
+    udp_port = strtol(udpPort, &endptr, 0);
+    if ( *endptr ) {
+    	printf("ECHOCLNT: Invalid port supplied.\n");
+    	exit(EXIT_FAILURE);
+    }
+	
+
+    /*  Create the listening socket  */
+
+    if ( (socket_udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
+    	fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
+    	exit(EXIT_FAILURE);
+    }
+
+    /*  Set all bytes in socket address structure to
+        zero, and fill in the relevant data members   */
+
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family      = AF_INET;
+    servaddr.sin_port        = htons(udp_port);
 
 
     /*  Set the remote IP address  */
@@ -94,7 +136,7 @@ int main(int argc, char *argv[]) {
     
     /*  connect() to the remote echo server  */
 
-    if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
+    if ( connect(socket_udp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
     	printf("ECHOCLNT: Error calling connect()\n");
     	exit(EXIT_FAILURE);
     }

commit 7b8ecb3d1f8446d8a0b0d20b9942145ef52916bb
Author: Ashok Tamang <ashok.tamang@bison.howard.edu>
Date:   Sat Feb 11 13:02:36 2017 -0500

    Implement required command line arguments in client.

diff --git a/client/client.c b/client/client.c
index ff1cb18..81178f6 100644
--- a/client/client.c
+++ b/client/client.c
@@ -32,21 +32,24 @@
 
 /*  Function declarations  */
 
-int ParseCmdLine(int argc, char *argv[], char **szAddress, char **szPort);
+int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort);
 
 
 /*  main()  */
 
 int main(int argc, char *argv[]) {
 
-    int       conn_s;                     /*  connection socket                  */
-    short int port;                       /*  port number                        */
+    int       socket_tcp;                    /*  connection socket                  */
+    int	      socket_udp;
+    short int tcp_port;                   /*  tcp port number                        */
+    short int udp_port;                   /*  udp port number                    */
     struct    sockaddr_in servaddr;       /*  socket address structure           */
     char      buffer[MAX_LINE];           /*  character buffer                   */
     char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
     char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
     char     *szAddress;                  /*  Holds remote IP address            */
-    char     *szPort;                     /*  Holds remote port                  */
+    char     *udpPort;			 /* Holds server upd port */
+    char     *tcpPort;                     /*  Holds server tcp port                  */
     char     *endptr;                     /*  for strtol()                       */
     FILE     *fp;                         /*  file pointer                       */
     char     *file_name;                  /*  for creating and writing data into */
@@ -54,12 +57,12 @@ int main(int argc, char *argv[]) {
 
     /*  Get command line arguments  */
 
-    ParseCmdLine(argc, argv, &szAddress, &szPort);
+    ParseCmdLine(argc, argv, &szAddress, &tcpPort, &udpPort);
 
 
     /*  Set the remote port  */
 
-    port = strtol(szPort, &endptr, 0);
+    tcp_port = strtol(tcpPort, &endptr, 0);
     if ( *endptr ) {
     	printf("ECHOCLNT: Invalid port supplied.\n");
     	exit(EXIT_FAILURE);
@@ -68,7 +71,7 @@ int main(int argc, char *argv[]) {
 
     /*  Create the listening socket  */
 
-    if ( (conn_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+    if ( (socket_tcp = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
     	fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
     	exit(EXIT_FAILURE);
     }
@@ -78,7 +81,7 @@ int main(int argc, char *argv[]) {
 
     memset(&servaddr, 0, sizeof(servaddr));
     servaddr.sin_family      = AF_INET;
-    servaddr.sin_port        = htons(port);
+    servaddr.sin_port        = htons(tcp_port);
 
 
     /*  Set the remote IP address  */
@@ -91,7 +94,7 @@ int main(int argc, char *argv[]) {
     
     /*  connect() to the remote echo server  */
 
-    if ( connect(conn_s, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
+    if ( connect(socket_tcp, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
     	printf("ECHOCLNT: Error calling connect()\n");
     	exit(EXIT_FAILURE);
     }
@@ -111,8 +114,8 @@ int main(int argc, char *argv[]) {
             strcat(buffer_send, buffer);
             strcat(buffer_send, "\n");
 
-            write(conn_s, buffer_send, strlen(buffer_send));
-            read(conn_s, buffer_received, MAX_LINE-1);
+            write(socket_tcp, buffer_send, strlen(buffer_send));
+            read(socket_tcp, buffer_received, MAX_LINE-1);
 
             /* reset buffer to get only relevant string */
             memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
@@ -132,10 +135,10 @@ int main(int argc, char *argv[]) {
             strcat(buffer_send, buffer);
 
             /* Send message to server. */
-            write(conn_s, buffer_send, strlen(buffer_send));
+            write(socket_tcp, buffer_send, strlen(buffer_send));
 
             /* Read message from server. */
-            read(conn_s, buffer_received, MAX_LINE-1);
+            read(socket_tcp, buffer_received, MAX_LINE-1);
  
             /* write the data to the file. */
             if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {
@@ -152,7 +155,7 @@ int main(int argc, char *argv[]) {
         }
         else if (strncmp(buffer, "q", 1) == 0) {
             fprintf(stderr, "Now should exit.\n");
-            if (close(conn_s) < 0 ) {
+            if (close(socket_tcp) < 0 ) {
                 fprintf(stderr, "ECHOSERV: Error calling close()\n");
                 exit(EXIT_FAILURE);
             }
@@ -173,15 +176,16 @@ int main(int argc, char *argv[]) {
 }
 
 
-int ParseCmdLine(int argc, char *argv[], char **szAddress, char **szPort) {
-    /* Number of arguments: <clent> <ip> <port> (3 arguments). */
-    if (argc == 3) {
-        *szAddress = argv[1];
-	    *szPort = argv[2];
+int ParseCmdLine(int argc, char *argv[], char **szAddress, char **tcpPort, char **udpPort) {
+    /* Number of arguments: <client> <TCP port> <server IP> <server UDP Port> (4 arguments). */
+    if (argc == 4) {
+	*tcpPort = argv[1];
+        *szAddress = argv[2];
+	*udpPort = argv[3];
     }
 	else {
 	    printf("Usage:\n\n");
-	    printf("    <client> <IP address> <remote Port>\n\n");
+	    printf("    <client> <TCP port> <server IP> <server UDP Port>\n\n");
 	    exit(EXIT_SUCCESS);
 	}
     return 0;

commit c732af8581e15fb6690f4bb774d166c22fc8f2ae
Author: ashok <ashok@ashok-VirtualBox.(none)>
Date:   Tue Feb 7 15:52:08 2017 -0500

    Starter project for project 1: 'TCP Socket Project'

diff --git a/client/Makefile b/client/Makefile
new file mode 100644
index 0000000..33c3f1f
--- /dev/null
+++ b/client/Makefile
@@ -0,0 +1,11 @@
+client: client.o helper.o
+	gcc -o client client.o helper.o -Wall
+
+client.o: client.c helper.h
+	gcc -o client.o client.c -c -ansi -pedantic -Wall -D_BSD_SOURCE
+
+helper.o: helper.c helper.h
+	gcc -o helper.o helper.c -c -ansi -pedantic -Wall
+
+clean:
+	rm helper.o client.o client
diff --git a/client/README b/client/README
new file mode 100644
index 0000000..cd869c0
--- /dev/null
+++ b/client/README
@@ -0,0 +1,40 @@
+ECHOCLNT
+========
+(c) Paul Griffiths, 1999
+Email: mail@paulgriffiths.net
+
+
+Function
+========
+
+Demonstrates a simple TCP/IP echo client, using the
+Berkeley Sockets API. This program is meant to work
+in conjunction with ECHOSERV, a simple TCP/IP echo server
+also available from this site.
+
+
+Usage
+=====
+
+Example of usage:
+
+    [paul@localhost paul]$ ./echoclnt -a 127.0.0.1 -p 3357
+
+Switches:
+
+	-p : specifies remote port of time server
+	-a : specifies remote address of time server
+
+
+Installation
+============
+
+If your system supports make, simply type:
+
+    make
+
+at the command line. Otherwise, compile and link echoclnt.c
+and helper.c in the usual way to create the executable. You may or may
+not need to link in additional libraries for the sockets
+functions; check your compiler's documentation.
+
diff --git a/client/client.c b/client/client.c
new file mode 100644
index 0000000..ff1cb18
--- /dev/null
+++ b/client/client.c
@@ -0,0 +1,189 @@
+/*
+  CLIENT.C
+  ==========
+  (c) Ashok Tamang, 2017
+  Email: ashok.tamang@bison.howard.edu
+  Networking and Web Programming, Spring 2017
+
+  -------------------------
+  Adapted from EchoServ by:
+  (c) Paul Griffiths, 1999
+  Email: mail@paulgriffiths.net
+  
+  Simple TCP/IP echo client.
+
+*/
+
+
+#include <sys/socket.h>       /*  socket definitions        */
+#include <netinet/in.h>
+#include <sys/types.h>        /*  socket types              */
+#include <arpa/inet.h>        /*  inet (3) funtions         */
+#include <unistd.h>           /*  misc. UNIX functions      */
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+
+/*  Global constants  */
+
+#define MAX_LINE           (1000)
+
+
+/*  Function declarations  */
+
+int ParseCmdLine(int argc, char *argv[], char **szAddress, char **szPort);
+
+
+/*  main()  */
+
+int main(int argc, char *argv[]) {
+
+    int       conn_s;                     /*  connection socket                  */
+    short int port;                       /*  port number                        */
+    struct    sockaddr_in servaddr;       /*  socket address structure           */
+    char      buffer[MAX_LINE];           /*  character buffer                   */
+    char      buffer_send[MAX_LINE];      /*  Holds message to be send to server */
+    char      buffer_received[MAX_LINE];  /*  Holds message send by server       */
+    char     *szAddress;                  /*  Holds remote IP address            */
+    char     *szPort;                     /*  Holds remote port                  */
+    char     *endptr;                     /*  for strtol()                       */
+    FILE     *fp;                         /*  file pointer                       */
+    char     *file_name;                  /*  for creating and writing data into */
+
+
+    /*  Get command line arguments  */
+
+    ParseCmdLine(argc, argv, &szAddress, &szPort);
+
+
+    /*  Set the remote port  */
+
+    port = strtol(szPort, &endptr, 0);
+    if ( *endptr ) {
+    	printf("ECHOCLNT: Invalid port supplied.\n");
+    	exit(EXIT_FAILURE);
+    }
+	
+
+    /*  Create the listening socket  */
+
+    if ( (conn_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+    	fprintf(stderr, "ECHOCLNT: Error creating listening socket.\n");
+    	exit(EXIT_FAILURE);
+    }
+
+    /*  Set all bytes in socket address structure to
+        zero, and fill in the relevant data members   */
+
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family      = AF_INET;
+    servaddr.sin_port        = htons(port);
+
+
+    /*  Set the remote IP address  */
+
+    if ( inet_aton(szAddress, &servaddr.sin_addr) <= 0 ) {
+    	printf("ECHOCLNT: Invalid remote IP address.\n");
+    	exit(EXIT_FAILURE);
+    }
+
+    
+    /*  connect() to the remote echo server  */
+
+    if ( connect(conn_s, (struct sockaddr *) &servaddr, sizeof(servaddr) ) < 0 ) {
+    	printf("ECHOCLNT: Error calling connect()\n");
+    	exit(EXIT_FAILURE);
+    }
+
+
+    /*  Get string to follow user commands */
+    do {
+        printf("Insert your command: ");
+        fgets(buffer, MAX_LINE, stdin);
+
+        if (strncmp(buffer, "s", 1) == 0) {
+            printf("\nPlease Enter a string: ");
+            fgets(buffer, MAX_LINE, stdin);
+            
+            /* Format the input string */
+            strcpy(buffer_send, "CAP\n");
+            strcat(buffer_send, buffer);
+            strcat(buffer_send, "\n");
+
+            write(conn_s, buffer_send, strlen(buffer_send));
+            read(conn_s, buffer_received, MAX_LINE-1);
+
+            /* reset buffer to get only relevant string */
+            memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+            
+            memcpy(buffer, buffer_received + 2, strlen(buffer_received) - 2);
+            printf("Server responded: %s", buffer);
+        }
+        else if (strncmp(buffer, "t", 1) == 0) {
+            printf("\nPlease Enter a string: ");
+            fgets(buffer, MAX_LINE, stdin);
+            
+            file_name = (char*) malloc (sizeof(char*) * (strlen(buffer) - 1));
+            memcpy(file_name, buffer, strlen(buffer) - 1);  
+
+            /* Format the input string */
+            strcpy(buffer_send, "FILE\n");
+            strcat(buffer_send, buffer);
+
+            /* Send message to server. */
+            write(conn_s, buffer_send, strlen(buffer_send));
+
+            /* Read message from server. */
+            read(conn_s, buffer_received, MAX_LINE-1);
+ 
+            /* write the data to the file. */
+            if (strncmp(buffer_received + 2, "NOT FOUND", 9) == 0) {
+                printf("Server responded: %s\n", buffer_received + 2);
+            }
+            else {
+                fp = fopen(file_name, "wb");
+                fwrite(buffer_received, 1, strlen(buffer_received), fp);
+                printf("Server responded: Data is written to the file named: %s\n", file_name);
+                /* close the file and free the memory */
+                fclose(fp);
+                free(file_name);
+            }
+        }
+        else if (strncmp(buffer, "q", 1) == 0) {
+            fprintf(stderr, "Now should exit.\n");
+            if (close(conn_s) < 0 ) {
+                fprintf(stderr, "ECHOSERV: Error calling close()\n");
+                exit(EXIT_FAILURE);
+            }
+
+            return EXIT_SUCCESS;
+        }
+        else 
+            printf("\nInvalid Command: Press 's' for echo, 't' for file storage and 'q' for exit.\n");
+
+        /* free the memory */
+        memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+        memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
+        memset(buffer_received, 0, (sizeof buffer_received[0]) * MAX_LINE);
+    
+    } while (strncmp(buffer, "q", 1) != 0);
+
+    return EXIT_SUCCESS;
+}
+
+
+int ParseCmdLine(int argc, char *argv[], char **szAddress, char **szPort) {
+    /* Number of arguments: <clent> <ip> <port> (3 arguments). */
+    if (argc == 3) {
+        *szAddress = argv[1];
+	    *szPort = argv[2];
+    }
+	else {
+	    printf("Usage:\n\n");
+	    printf("    <client> <IP address> <remote Port>\n\n");
+	    exit(EXIT_SUCCESS);
+	}
+    return 0;
+}
+
diff --git a/client/helper.c b/client/helper.c
new file mode 100644
index 0000000..2a5a865
--- /dev/null
+++ b/client/helper.c
@@ -0,0 +1,81 @@
+/*
+
+  HELPER.C
+  ========
+  (c) Paul Griffiths, 1999
+  Email: mail@paulgriffiths.net
+
+  Implementation of sockets helper functions.
+
+  Many of these functions are adapted from, inspired by, or 
+  otherwise shamelessly plagiarised from "Unix Network 
+  Programming", W Richard Stevens (Prentice Hall).
+
+*/
+
+#include "helper.h"
+#include <sys/socket.h>
+#include <unistd.h>
+#include <errno.h>
+
+
+/*  Read a line from a socket  */
+
+ssize_t Readline(int sockd, void *vptr, size_t maxlen) {
+    ssize_t n, rc;
+    char    c, *buffer;
+
+    buffer = vptr;
+
+    for ( n = 1; n < maxlen; n++ ) {
+	
+		if ( (rc = read(sockd, &c, 1)) == 1 ) {
+		    *buffer++ = c;
+		    if ( c == '\n' )
+				break;
+		}
+		else if ( rc == 0 ) {
+		    if ( n == 1 )
+				return 0;
+		    else
+				break;
+		}
+		else {
+		    if ( errno == EINTR )
+				continue;
+		    return -1;
+		}
+    }
+
+    *buffer = 0;
+    return n;
+}
+
+
+/*  Write a line to a socket  */
+
+ssize_t Writeline(int sockd, const void *vptr, size_t n) {
+    size_t      nleft;
+    ssize_t     nwritten;
+    const char *buffer;
+
+    buffer = vptr;
+    nleft  = n;
+
+    while ( nleft > 0 ) {
+		if ( (nwritten = write(sockd, buffer, nleft)) <= 0 ) {
+		    if ( errno == EINTR )
+				nwritten = 0;
+		    else
+				return -1;
+		}
+		nleft  -= nwritten;
+		buffer += nwritten;
+    }
+
+    return n;
+}
+
+
+
+
diff --git a/client/helper.h b/client/helper.h
new file mode 100644
index 0000000..250657f
--- /dev/null
+++ b/client/helper.h
@@ -0,0 +1,33 @@
+/*
+
+  HELPER.H
+  ========
+  (c) Paul Griffiths, 1999
+  Email: mail@paulgriffiths.net
+
+  Interface to socket helper functions. 
+
+  Many of these functions are adapted from, inspired by, or 
+  otherwise shamelessly plagiarised from "Unix Network 
+  Programming", W Richard Stevens (Prentice Hall).
+
+*/
+
+
+#ifndef PG_SOCK_HELP
+#define PG_SOCK_HELP
+
+
+#include <unistd.h>             /*  for ssize_t data type  */
+
+#define LISTENQ        (1024)   /*  Backlog for listen()   */
+
+
+/*  Function declarations  */
+
+ssize_t Readline(int fd, void *vptr, size_t maxlen);
+ssize_t Writeline(int fc, const void *vptr, size_t maxlen);
+
+
+#endif  /*  PG_SOCK_HELP  */
+
diff --git a/server/Makefile b/server/Makefile
new file mode 100644
index 0000000..8a6bf3f
--- /dev/null
+++ b/server/Makefile
@@ -0,0 +1,19 @@
+server: server.o helper.o
+	gcc -o server server.o helper.o -Wall
+
+server.o: server.c helper.h
+	gcc -o server.o server.c -c -ansi -pedantic -Wall
+
+helper.o: helper.c helper.h
+	gcc -o helper.o helper.c -c -ansi -pedantic -Wall
+
+clean:
+	rm helper.o server.o server
+
+
+
+
+
+
+
+
diff --git a/server/README b/server/README
new file mode 100644
index 0000000..e5086e6
--- /dev/null
+++ b/server/README
@@ -0,0 +1,41 @@
+ECHOSERV
+========
+(c) Paul Griffiths, 1999
+Email: mail@paulgriffiths.net
+
+
+Function
+========
+
+Demonstrates a simple TCP/IP echo server, using the
+Berkeley Sockets API. 
+
+
+Usage
+=====
+
+Example of usage:
+
+    [paul@localhost paul]$ ./echoserv 5555 &
+    [paul@localhost paul]$ telnet localhost 5555
+    Trying 127.0.0.1...
+    Connected to localhost.
+    Escape character is '^]'.
+    Echo this line for me, please.
+    Echo this line for me, please.
+    Connection closed by foreign host.
+    [paul@localhost paul]$
+
+
+Installation
+============
+
+If your system supports make, simply type:
+
+    make
+
+at the command line. Otherwise, compile and link echoserv.c and
+help.c in the usual way to create the executable. You may or may
+not need to link in additional libraries for the sockets functions;
+check your compiler's documentation.
+
diff --git a/server/helper.c b/server/helper.c
new file mode 100644
index 0000000..6731080
--- /dev/null
+++ b/server/helper.c
@@ -0,0 +1,82 @@
+/*
+
+  HELPER.C
+  ========
+  (c) Paul Griffiths, 1999
+  Email: mail@paulgriffiths.net
+
+  Implementation of sockets helper functions.
+
+  Many of these functions are adapted from, inspired by, or 
+  otherwise shamelessly plagiarised from "Unix Network 
+  Programming", W Richard Stevens (Prentice Hall).
+
+*/
+
+#include "helper.h"
+#include <sys/socket.h>
+#include <unistd.h>
+#include <errno.h>
+
+
+/*  Read a line from a socket  */
+
+ssize_t Readline(int sockd, void *vptr, size_t maxlen) {
+    ssize_t n, rc;
+    char    c, *buffer;
+
+    buffer = vptr;
+
+    for ( n = 1; n < maxlen; n++ ) {
+	
+	if ( (rc = read(sockd, &c, 1)) == 1 ) {
+	    *buffer++ = c;
+	    /*if ( c == '\n' )
+		break;
+		*/
+	}
+	else if ( rc == 0 ) {
+	    if ( n == 1 )
+		return 0;
+	    else
+		break;
+	}
+	else {
+	    if ( errno == EINTR )
+		continue;
+	    return -1;
+	}
+    }
+
+    *buffer = 0;
+    return n;
+}
+
+
+/*  Write a line to a socket  */
+
+ssize_t Writeline(int sockd, const void *vptr, size_t n) {
+    size_t      nleft;
+    ssize_t     nwritten;
+    const char *buffer;
+
+    buffer = vptr;
+    nleft  = n;
+
+    while ( nleft > 0 ) {
+	if ( (nwritten = write(sockd, buffer, nleft)) <= 0 ) {
+	    if ( errno == EINTR )
+		nwritten = 0;
+	    else
+		return -1;
+	}
+	nleft  -= nwritten;
+	buffer += nwritten;
+    }
+
+    return n;
+}
+
+
+
+
diff --git a/server/helper.h b/server/helper.h
new file mode 100644
index 0000000..250657f
--- /dev/null
+++ b/server/helper.h
@@ -0,0 +1,33 @@
+/*
+
+  HELPER.H
+  ========
+  (c) Paul Griffiths, 1999
+  Email: mail@paulgriffiths.net
+
+  Interface to socket helper functions. 
+
+  Many of these functions are adapted from, inspired by, or 
+  otherwise shamelessly plagiarised from "Unix Network 
+  Programming", W Richard Stevens (Prentice Hall).
+
+*/
+
+
+#ifndef PG_SOCK_HELP
+#define PG_SOCK_HELP
+
+
+#include <unistd.h>             /*  for ssize_t data type  */
+
+#define LISTENQ        (1024)   /*  Backlog for listen()   */
+
+
+/*  Function declarations  */
+
+ssize_t Readline(int fd, void *vptr, size_t maxlen);
+ssize_t Writeline(int fc, const void *vptr, size_t maxlen);
+
+
+#endif  /*  PG_SOCK_HELP  */
+
diff --git a/server/server.c b/server/server.c
new file mode 100644
index 0000000..a26f05e
--- /dev/null
+++ b/server/server.c
@@ -0,0 +1,224 @@
+/*
+
+  SERVER.C
+  ==========
+  (c) Ashok Tamang, 2017
+  Email: ashok.tamang@bison.howard.edu
+  Networking and Web Programming, Spring 2017
+
+  -------------------------
+  Adapted from EchoServ by:
+  (c) Paul Griffiths, 1999
+  Email: mail@paulgriffiths.net
+  
+  Simple TCP/IP echo server.
+
+*/
+
+
+#include <sys/socket.h>       /*  socket definitions        */
+#include <sys/types.h>        /*  socket types              */
+#include <sys/time.h>
+#include <arpa/inet.h>        /*  inet (3) funtions         */
+#include <unistd.h>           /*  misc. UNIX functions      */
+
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+/*  Global constants  */
+#define MAX_LINE           (1000)
+#define LISTENQ            (1024)   /*  Backlog for listen()   */
+
+
+
+int main(int argc, char *argv[]) {
+    int       list_s;                /*  listening socket          */
+    int       conn_s;                /*  connection socket         */
+    short int port;                  /*  port number               */
+    struct    sockaddr_in servaddr;  /*  socket address structure  */
+    char      buffer[MAX_LINE];      /*  character buffer          */
+    char      buffer_send[MAX_LINE];
+    char     *endptr;                /*  for strtol()              */
+    char     *to_capitalize;         /*  store user string to capitalize */
+    char     *file_name;             /*  for storing file_name to be searched in the server */
+    FILE     *fp;                    /*  file pointer */
+
+
+    /*  Get port number from the command line.*/
+
+    if ( argc == 2 ) {
+    	port = strtol(argv[1], &endptr, 0);
+    	if ( *endptr ) {
+    	    fprintf(stderr, "ECHOSERV: Invalid port number.\n");
+    	    exit(EXIT_FAILURE);
+	   }
+    }
+    else {
+    	fprintf(stderr, "ECHOSERV: Invalid arguments.\n");
+        printf("Usage:\n\n");
+        printf("    <server> <remote Port>\n\n");
+    	exit(EXIT_FAILURE);
+    }
+
+	
+    /*  Create the listening socket  */
+
+    if ((list_s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
+    	perror("ECHOSERV: Error creating listening socket.\n");
+
+    	exit(EXIT_FAILURE);
+    }
+
+
+    /*  Set all bytes in socket address structure to
+        zero, and fill in the relevant data members   */
+
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family      = AF_INET;
+    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    servaddr.sin_port        = htons(port);
+
+
+    /*  Bind our socket addresss to the 
+	listening socket, and call listen()  */
+
+    if ( bind(list_s, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 ) {
+    	fprintf(stderr, "ECHOSERV: Error calling bind()\n");
+    	exit(EXIT_FAILURE);
+    }
+
+    if ( listen(list_s, LISTENQ) < 0 ) {
+    	perror("ECHOSERV: Error calling listen()\n");
+    	exit(EXIT_FAILURE);
+     }
+
+    
+    /*  Enter an infinite loop to respond to client requests.  */
+
+    while ( 1 ) {
+    	/*  Wait for a connection, then accept() it  */
+
+    	if ( (conn_s = accept(list_s, NULL, NULL) ) < 0 ) {
+    	    fprintf(stderr, "ECHOSERV: Error calling accept()\n");
+    	    exit(EXIT_FAILURE);
+    	}
+
+        /*  
+          Retrieve an input line from the connected socket
+          then simply write it back to the  same socket.     
+        */
+
+        while (1) {
+            read(conn_s, buffer, MAX_LINE-1);
+
+            if (strncmp(buffer, "CAP", 3) == 0) {
+                /* number of relevant bytes of message 
+                   = buffer length - 'CAP' length - length of two line breaks - end of string 
+                */
+
+                to_capitalize =  (char* ) malloc(sizeof(char*) * (strlen(buffer) - 6));
+                memcpy(to_capitalize, buffer + 4, strlen(buffer) - 6);
+
+                /* Capitalize the messsage */
+                int index = 0;
+                while (to_capitalize[index] != '\0') {
+                    if (islower(to_capitalize[index])) {
+                        to_capitalize[index] = toupper(to_capitalize[index]);
+                    }
+                    else {
+                        to_capitalize[index] = to_capitalize[index];
+                    }
+                    index++;
+                }
+
+                /* parse the capitalized message to send to the client */
+                
+                sprintf(buffer_send, "%d", strlen(to_capitalize));
+                strcat(buffer_send, "\n");
+                strcat(buffer_send, to_capitalize);
+
+                /* send the formatted message to the client */
+                write(conn_s, buffer_send, strlen(buffer_send));
+
+                /* free the memory */
+                free(to_capitalize);
+                
+            }
+
+            if (strncmp(buffer, "FILE", 4) == 0) {
+                file_name = (char* ) malloc (sizeof(char*) * (strlen(buffer) - 6));
+                memcpy(file_name, buffer + 5, strlen(buffer) - 6);
+
+                /* Find file name and read that file */
+                fp = fopen(file_name, "rb");
+                if (fp) {
+                    long lSize;
+                    void* large_buffer;
+                    size_t result;
+
+                    /* obtain file size */
+                    fseek(fp, 0, SEEK_END);
+                    lSize = ftell(fp);
+                    rewind(fp); /* Put the postion of pointer back to the start of the file */
+
+                    /* allocate memory to hold the whole file */
+                    large_buffer = (void* ) malloc(sizeof(void*) * lSize);
+                    if (large_buffer == NULL) {
+                        perror("Error in allocating required memory: ");
+                    }
+
+                    /* copy the file into the buffer */
+                    result = fread(large_buffer, 1, lSize, fp);
+                    if (result != lSize) {
+                        printf("Error reading whole file.\n");
+                    }
+
+                    /* close the file and later free the large_buffer */
+                    fclose(fp);
+
+                    /* send the buffer to the client */
+                    if (MAX_LINE < lSize) {
+                        strcpy(buffer_send, "The buffer size is smaller than what needs to be sent.");
+                        write(conn_s, buffer_send, strlen(buffer_send));
+                    }
+                    else {
+                        sprintf(buffer_send, "%d", lSize);
+                        strcat(buffer_send, "\n");
+                        strcat(buffer_send, large_buffer);
+                        write(conn_s, buffer_send, lSize);
+                    }
+
+                    /* free the memory */
+                    free(large_buffer);
+                    free(file_name);
+                } else {
+                    /* No such file */
+                    strcpy(buffer, "NOT FOUND");
+                    sprintf(buffer_send, "%d", strlen(buffer));
+                    strcat(buffer_send, "\n");
+                    strcat(buffer_send, buffer);
+
+                    /* Inform client that file is not in the server. */
+                    write(conn_s, buffer_send, strlen(buffer_send));
+                }
+
+            }
+
+            /* free the memory */
+            memset(buffer, 0, (sizeof buffer[0]) * MAX_LINE);
+            memset(buffer_send, 0, (sizeof buffer_send[0]) * MAX_LINE);
+        }
+
+    	/*  Close the connected socket  */
+    	if ( close(conn_s) < 0 ) {
+    	    perror("ECHOSERV: Error calling close()\n");
+    	    exit(EXIT_FAILURE);
+    	}
+        else {
+            fprintf(stderr, "Connection closed.\n");
+        }
+    }
+}

commit a61efafe3bf58b3205ef002c67043b1f21496274
Author: ashoktamang52 <ashok.tamang@bison.howard.edu>
Date:   Tue Feb 7 15:48:25 2017 -0500

    Initial commit

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..6bc893f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,2 @@
+# CSCI-452-UDP-Socket-Project
+UDP Socket Project, CSCI 452: Networking and Web Programming
